const data = [
    {
        block: "JMETER",
        question: "Что такое МНТ?",
        answer: "Методика нагрузочного тестирования – единый документ, который полностью описывает все вводные проекта, отвечает на вопросы, что, где, когда и как проводится тестирование конкретной системы."
    },
    {
        block: "JMETER",
        question: "Причины написания МНТ",
        answer: "• Причина бюрократическая: написание МНТ - это частое требование заказчиков, оно вызвано требованиями выдать документ, который будет регулировать планируемые действия\n• Причина менеджерская: частое требования менеджера, который понимает, что тестирование, которое проводим должно быть выполнено любым другим работником. Т.е. для передачи дел другому инженеру\n• Причина инженерская: должно быть личным желанием инженера НТ сформировать полное, структурированное понимание о системе. Самому зафиксировать цели и планы чтобы не упустить важных договоренностей с командой разработки и менеджерами во время тестирования"
    },
    {
        block: "JMETER",
        question: "Основные разделы МНТ",
        answer: "• Цели: что хотим от тестирования, что мы хотим получить в результате НТ\n• Сравнения тестового и промышленного стендов: логично сравнивать на чем тестируем, т.к. нас интересует тестируемая система будет вести себя на промышленном стенде, а тестировать будем на тестовом. Следовательно нужно заранее проговорить, что будет и чего не будет на тестовых и промышленных стендах.\n• Ограничения тестирования: зачастую бывает такое, что условия в промышленной эксплуатацией на 100% с тестовой эксплуатацией. Например ряд запросов используемых редко мы просто не будем использовать. Задача полностью прописать различия между промышленной и тестовой эксплуатацией.\n• Профиль нагрузки: перечисление чем подается нагрузка, какие заглушки используются, какие программы используются для нашего результата\n• Стратегия нагрузочного тестирования (сценарий НТ): описывается весь процесс тестирования: какие тесты проводить, как готовиться к этим тестам, как собирать результаты.\n• Средства нагрузочного тестирования: перечисляется чем подается нагрузка, какие заглушки используются, какие программы используются для анализа\n• Критерии завершения тестирования: указать, что формально система тестирования окончена, когда провели тесты, собрали данные для анализа и видами заключения.\n• Критерии успешности тестирования: данный раздел предназначен для описания значений метрик за которые мы не должны переваливать, например ЦПУ, время выполнения операций\n• Наполнение БД: необходимо указать действия с БД, которые нужно совершать перед тестированием и перед каждым тестом, например генерация тестовых данных\n• Мониторинг: описать что мы мониторим, какие сервера и метрики.\n• Отчет НТ: фиксация результатов проведенных тестов инженером НТ"
    },
    {
        block: "JMETER",
        question: "Для чего проводится тест стабильности(надежности)?",
        answer: "Распространенная цель теста надежности – это проверка на утечку памяти. Смотрим копятся ли объекты в памяти. Смотрим за ростом БД. Утечка памяти – это постепенный рост утилизации оперативной памяти при работе приложения. Превышение утилизации памяти максимального лимита приводит к остановке приложения по ошибке OutOfMemory."
    },
    {
        block: "JMETER",
        question: "Набор стандартных тестов",
        answer: "• Быстрый поиск максимума – плавно повышаем нагрузку от нуля до заведомо большего значения. Останавливаем тест при нарушении какого-либо показателя. Запускается на короткое количество времени. Делается для того чтобы легче\n• Поиск максимальной производительности проводится из двух частей:\n1.Подготовка:\no Проводится быстрый поиск максимума\no Фиксируется примерная максимальная пропускная способность, умноженная на 1.2 на 100% - предполагаемая максимальная нагрузка\no Формируется шаг нагрузки – 10% от предполагаемой максимальной нагрузки\n2. Тест:\no Подается нагрузка интенсивностью в один шаг\no Увеличивается на шаг через фиксированное время (например 10 минут) до достижения предполагаемой максимальной нагрузки\no При нарушении одного или нескольких показателей на определенной ступени останавливаем тест\no Фиксируется максимальная производительность интенсивности предыдущего шага\n3. Цель:\no Определить максимальную нагрузку\no Выявить проблемы с производительностью\no Определить узкие места\n• Базовый профиль:\n1.Подготовка:\no Определяются бизнес требования в части пропускной способности как целевая нагрузка\no Определяется скорость входа пользователей, чтобы система не деградировала от резкого скачка нагрузки\n2. Тест:\no Увеличиваем нагрузку от нуля до целевого значения\no Держим нагрузку в течении 1-3 часов\n3. Цель:\no Проверка работы на целевой нагрузки\n• Тест надежности\n1.Подготовка:\no Определяется интенсивность нагрузки как 70-80% от максимальной производительности системы как нагрузка надежности\n2. Тест:\no Увеличиваем нагрузку от нуля до целевого значения нагрузки надежности\n3. Цель:\no Проверка работы при длительной нагрузке\no Распространенная цель теста надежности – это проверка на утечку памяти. Утечка памяти – это постепенный рост утилизации оперативной памяти при работе приложения. Превышение утилизации памяти максимального лимита приводит к остановке приложения по ошибке OutOfMemory.\n• Отказоустойчивость (дополнительный тест) какого-либо элемента архитектуры\n1.Подготовка:\no Запускается тест интенсивностью нагрузки надежности (все зависит от пожелания заказчиков, интенсивность может варьироваться)\n2. Тест:\no Отключаем элемент (например БД) на 15 минут\no Восстанавливаем работу\n3. Цель:\no Подготовить разработчиков к неожиданным инцидентам\no Проверить работоспособность при недоступности\no Замерить время восстановления после аварии"
    },
    {
        block: "JMETER",
        question: "Paicing",
        answer: "интервал времени в течение которого гарантировано выполняется один проход сценария. Время выделенное на прохождение одной итерации. Время между итерациями, позволяет сделать запас времени, выставляется на x2 от времени пользователя воизбежании накладывания итераций\nЗначение должно быть больше времени выполнения скрипта\nЧем больше значение пейсинга, тем больше потратиться виртуальных пользователей\nЕсли время работы скрипта во время теста превышает пейсинг то этот тест считается не валидным. Увеличение числа виртуальных пользователей ведет к увеличению ресурсов генераторов нагрузки. С помощью параметра пейсинг инженер НТ контролирует количество операций который пройдет один вузер за единицу времени"
    },
    {
        block: "JMETER",
        question: "Задание, есть требования по времени отклика максимальное 3 секуны по SLA , какой Paicing выствлять?",
        answer: "выставляется на x2 от времени отклика по SLA воизбежании накладывания итераций\nЗначение должно быть больше времени выполнения скрипта. Если время работы скрипта во время теста превышает пейсинг то этот тест считается не валидным, потому что может сильно разъехаться профиль"
    },
    {
        block: "JMETER",
        question: "Корреляция в JMETER? какие инструменты?",
        answer: "Корреляция в JMETER - это динамические данные. На примере тестового проекта в запрсое sendMessage требовалось направлять рандомные сообщения, для этого я использовала JSR PreProcessor, который генерировал рандомные сообщения, далее вывод резульатата в переменную и подсставлению в сэмплер в моем случае в путь запроса."
    },
    {
        block: "JMETER",
        question: "Код состояния HTTP-запроса",
        answer: "Информационные (1xx)\nЭти коды указывают на то, что запрос был получен и продолжает обрабатываться.\n• 100 Continue: Сервер получил начальную часть запроса и клиент должен продолжать отправлять запрос.\n• 101 Switching Protocols: Клиент запросил изменение протокола, и сервер согласился на это.\n\nУспешные (2xx)\nЭти коды указывают на то, что запрос был успешно получен, понято и принято.\n• 200 OK: Запрос выполнен успешно. Результат запроса (если есть) передается в теле ответа.\n• 201 Created: Запрос выполнен, и в результате был создан новый ресурс.\n• 202 Accepted: Запрос принят, но еще не обработан.\n• 204 No Content: Запрос выполнен успешно, но в ответе нет содержимого.\n\nПеренаправления (3xx)\nЭти коды указывают на то, что клиент должен выполнить дополнительные действия для завершения запроса.\n• 301 Moved Permanently: Запрашиваемый ресурс был перемещен на новый постоянный URL.\n• 302 Found: Ресурс временно доступен по другому URL.\n• 304 Not Modified: Ресурс не был изменен с момента последнего запроса. Используется для кэширования.\n\nОшибки клиента (4xx)\nЭти коды указывают на то, что ошибка произошла на стороне клиента.\n• 400 Bad Request: Сервер не может обработать запрос из-за ошибки клиента (например, синтаксическая ошибка).\n• 401 Unauthorized: Для доступа к запрашиваемому ресурсу требуется аутентификация.\n• 403 Forbidden: Сервер понял запрос, но отказывается его выполнять. У клиента нет прав для доступа к ресурсу.\n• 404 Not Found: Запрашиваемый ресурс не найден на сервере.\n• 405 Method Not Allowed: Метод, указанный в запросе, не разрешен для запрашиваемого ресурса.\n• 409 Conflict: Запрос не может быть выполнен из-за конфликта с текущим состоянием ресурса.\n\nОшибки сервера (5xx)\nЭти коды указывают на то, что ошибка произошла на стороне сервера.\n• 500 Internal Server Error: Внутренняя ошибка сервера. Сервер столкнулся с непредвиденной ситуацией.\n• 501 Not Implemented: Сервер не поддерживает функциональность, необходимую для выполнения запроса.\n• 502 Bad Gateway: Сервер получил недействительный ответ от вышестоящего сервера.\n• 503 Service Unavailable: Сервер временно недоступен из-за перегрузки или на техническое обслуживание.\n• 504 Gateway Timeout: Сервер не получил своевременный ответ от вышестоящего сервера."
    },
    {
        block: "АРХИТЕКТУРА",
        question: "Docker",
        answer: "Docker — это платформа для разработки, доставки и запуска приложений в изолированных контейнерах.\n• Контейнеры: Легковесные, автономные пакеты, содержащие все необходимое для работы приложения. Альтернативным подходом к изоляции приложений являются контейнеры. Само понятие контейнеров не ново и давно известно в Linux. Идея состоит в том, чтобы в рамках одной ОС выделить изолированную область и запускать в ней приложение. В этом случае говорим о виртуализации на уровне ОС. В отличие от ВМ контейнеры изолированно используют свой кусочек ОС:\n\n- дерево процессов\n- сетевые интерфейсы\n- файловая система\n\n• Образы (image): Шаблоны для создания контейнеров. Образ в первом приближении можно рассматривать как набор файлов. В состав образа входит все необходимое для запуска и работы приложения на голой машине с докером: ОС, среда выполнения и приложение, готовое к развертыванию. Образ состоит из слоев, каждый из которых представляет собой неизменяемую файловую систему, а по-простому набор файлов и директорий. Образ в целом представляет собой объединенную файловую систему (Union File System), которую можно рассматривать как результат слияния файловых систем слоев. Объединенная файловая система умеет обрабатывать конфликты, например, когда в разных слоях присутствуют файлы и директории с одинаковыми именами. Каждый следующий слой добавляет или удаляет какие то файлы из предыдущих слоев."
    },
    {
        block: "АРХИТЕКТУРА",
        question: "Чем отличаются метрики Node от метрик контейнера",
        answer: "Например, на Ноде утилизация CPU составляет 50 процентов, но при этом в контейнере будет 100, т.е. контейнер видит только выделенный ему объем CPU, у него есть свой определенный лимит."
    },
    {
        block: "SQL",
        question: "Типы БД",
        answer: "1. Реляционные базы данных (SQL)\n• Описание: Используют структурированные таблицы с фиксированными схемами для хранения данных. Основаны на языке SQL (Structured Query Language).\n• Примеры:\no MySQL\no PostgreSQL\no SQLite\no Microsoft SQL Server\no Oracle Database\n\n2. Документно-ориентированные базы данных (NoSQL)\n• Описание: Хранят данные в виде документов (обычно JSON). Подходят для хранения неструктурированных или полуструктурированных данных.\n• Примеры:\no MongoDB\no CouchDB\no RethinkDB\n\n3. Графовые базы данных (NoSQL)\n• Описание: Специализируются на хранении и обработке данных в виде графов. Подходят для работы с сетевыми и иерархическими структурами.\n• Примеры:\no Neo4j\no ArangoDB\no OrientDB\n\n4. Ключ-значение базы данных (NoSQL)\n• Описание: Хранят данные в виде пар 'ключ-значение'. Подходят для простых и быстрых операций чтения и записи.\n• Примеры:\no Redis\no Amazon DynamoDB\no Riak\n\n5. Временные базы данных (Time-series)\n• Описание: Оптимизированы для хранения и обработки временных рядов данных (например, данные датчиков, финансовые данные).\n• Примеры:\no InfluxDB\no TimescaleDB\no Graphite\n\n6. Объектно-ориентированные базы данных\n• Описание: Хранят данные в виде объектов, как в объектно-ориентированном программировании. Интегрируются с объектными языками программирования.\n• Примеры:\no db4o\no ObjectDB\no GemStone/S"
    },
    {
        block: "SQL",
        question: "Что такое план запроса в БД?",
        answer: "План запроса — это пошаговый процесс, который база данных использует для выполнения SQL-запроса. План запроса показывает, как база данных собирается получить данные, какие индексы и соединения она будет использовать, и в каком порядке будут обрабатываться таблицы и строки.\nОсновные моменты:\n1. Оптимизация запроса:\no План запроса помогает оптимизатору базы данных выбрать наилучший способ выполнения запроса. Оптимизатор анализирует возможные пути выполнения и выбирает наиболее эффективный.\n2. Использование индексов:\no План запроса показывает, какие индексы будут использоваться для ускорения поиска данных.\n3. Соединение таблиц:\no План запроса демонстрирует порядок соединения таблиц и метод соединения (например, вложенные циклы, хэш-соединение).\n4. Фильтрация данных:\no План запроса указывает, где и как будут применяться фильтры (условия WHERE), чтобы отобрать нужные данные.\nПример использования:\nПример запроса:\nSELECT * FROM orders WHERE customer_id = 123;\n\nПример плана запроса (на основе PostgreSQL):\nEXPLAIN SELECT * FROM orders WHERE customer_id = 123;\n\nВывод плана запроса:\nSeq Scan on orders  (cost=0.00..12.75 rows=1 width=48)\n Filter: (customer_id = 123)"
    },
    {
        block: "SQL",
        question: "Часто используемые команды в БД",
        answer: "1. DML (Data Manipulation Language) - Язык манипуляции данными\n• SELECT\no Описание: Извлекает данные из базы данных.\no Пример: SELECT * FROM users;\n• INSERT\no Описание: Добавляет новые записи в таблицу.\no Пример: INSERT INTO users (name, age) VALUES ('Alice', 30);\n• UPDATE\no Описание: Обновляет существующие записи в таблице.\no Пример: UPDATE users SET age = 31 WHERE name = 'Alice';\n• DELETE\no Описание: Удаляет записи из таблицы.\no Пример: DELETE FROM users WHERE name = 'Alice';\n\n2. DDL (Data Definition Language) - Язык определения данных\n• CREATE TABLE\no Описание: Создает новую таблицу.\no Пример: CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(100), age INT);\n• ALTER TABLE\no Описание: Изменяет структуру существующей таблицы.\no Пример: ALTER TABLE users ADD COLUMN email VARCHAR(100);\n• DROP TABLE\no Описание: Удаляет таблицу из базы данных.\no Пример: DROP TABLE users;\n• CREATE INDEX\no Описание: Создает индекс для ускорения поиска.\no Пример: CREATE INDEX idx_name ON users (name);\n• DROP INDEX\no Описание: Удаляет индекс.\no Пример: DROP INDEX idx_name;\n\n3. TCL (Transaction Control Language) - Язык управления транзакциями\n• BEGIN TRANSACTION\no Описание: Начинает транзакцию.\no Пример: BEGIN TRANSACTION;\n• COMMIT\no Описание: Фиксирует изменения, сделанные в рамках транзакции.\no Пример: COMMIT;\n• ROLLBACK\no Описание: Отменяет изменения, сделанные в рамках транзакции.\no Пример: ROLLBACK;\n\n4. DCL (Data Control Language) - Язык управления доступом\n• GRANT\no Описание: Предоставляет права пользователям на выполнение определенных операций.\no Пример: GRANT SELECT ON users TO some_user;\n• REVOKE\no Описание: Отзывает права у пользователей на выполнение определенных операций.\no Пример: REVOKE SELECT ON users FROM some_user;\n\n5. SCL (Schema Control Language) - Язык управления схемой\n• CREATE SCHEMA\no Описание: Создает новую схему в базе данных.\no Пример: CREATE SCHEMA marketing;\n• DROP SCHEMA\no Описание: Удаляет схему из базы данных.\no Пример: DROP SCHEMA marketing;"
    },
    {
        block: "",
        question: "Практичнская задача, есть микросервис, под ним какие то интеграции, входит в кафку и входит в БД, мы начинаем его грузить, но он не дает нарастить throughputb и cpu вообще не грузится,  и обрабатывает только один запрос,в чем может быть проблема и как бы анализоровал?",
        answer: "Подключение к микросервису в VisualVM:\n\nДействие: Запустите VisualVM и подключитесь к процессу вашего микросервиса.\nЗначение: Это позволит вам мониторить и профилировать микросервис в реальном времени.\n\nАнализ состояния потоков (Threads):\n\nДействие: Перейдите на вкладку 'Threads'.\nЧто это значит: Вы увидите текущее состояние всех потоков в вашем приложении.\nЧто мы найдем: Если большинство потоков находится в состоянии 'WAITING' или 'BLOCKED', это может указывать на проблемы с блокировками или синхронизацией.\n\nСнятие тред дампов (Thread Dumps):\n\nДействие: На вкладке 'Threads' снимите тред дамп (обычно кнопка 'Thread Dump').\nЧто это значит: Тред дамп представляет собой снимок всех потоков и их состояний в данный момент времени.\nЧто мы найдем: Вы сможете увидеть, какие потоки блокируют другие, и на каком участке кода происходит блокировка. Это поможет выявить проблемы с синхронизацией или deadlock'и.\n\nАнализ блокировок (Locks):\n\nДействие: Перейдите на вкладку 'Sampler' и выберите 'Threads'. Запустите захват данных (кнопка 'Sample').\nЧто это значит: Сэмплирование потоков поможет вам понять, какие методы и блокировки занимают много времени.\nЧто мы найдем: Вы сможете определить, какие потоки блокируют другие и где происходят задержки, что может указывать на узкие места в коде.\n\nПрофилирование CPU (CPU Profiling):\n\nДействие: Перейдите на вкладку 'Profiler' и запустите профилирование CPU (кнопка 'CPU' -> 'CPU Profiling').\nЧто это значит: Профилирование CPU покажет, какие методы занимают больше всего времени процессора.\nЧто мы найдем: Если профилирование показывает низкое использование CPU, это может указывать на то, что потоки ждут выполнения каких-то операций (например, I/O или сетевых операций).\n\nСнятие хип дампов (Heap Dumps):\n\nДействие: При необходимости, снимите хип дамп для анализа использования памяти (обычно кнопка 'Heap Dump').\nЧто это значит: Хип дамп покажет текущее состояние памяти и объекты, находящиеся в ней.\nЧто мы найдем: Вы сможете определить, есть ли утечки памяти или объекты, которые занимают слишком много места, что может влиять на производительность.\n\nЗаключение\n\nОбнаруженные проблемы и возможные решения:\n\nБлокировки и ожидания:\n\nПроблема: Если потоки находятся в состоянии 'WAITING' или 'BLOCKED', это может указывать на проблемы с синхронизацией или блокировками.\nРешение: Оптимизировать синхронизацию или пересмотреть использование блокировок для уменьшения конкуренции между потоками.\n\nНизкая загрузка CPU:\n\nПроблема: Если профилирование показывает низкое использование CPU, это может указывать на то, что потоки ждут завершения I/O операций.\nРешение: Оптимизировать I/O операции, использовать асинхронные вызовы или увеличить количество потоков для обработки запросов.\n\nУзкие места в коде:\n\nПроблема: Если профилирование CPU показывает, что некоторые методы занимают много времени, это может быть узким местом.\nРешение: Оптимизировать эти методы, используя более эффективные алгоритмы или улучшая код.\n\nИтог\n\nПроведение этих шагов в VisualVM поможет вам выявить и устранить проблемы, которые мешают вашему микросервису увеличивать throughput и загружать CPU. Анализ состояния потоков, снятие тред дампов, профилирование CPU и хип дампов дадут вам полное представление о работе вашего приложения и помогут найти узкие места."
    },
    {
        block: "JMETER",
        question: "Что такое нагрузочное тестирование?",
        answer: "Обычным языком: тестирование под нагрузкой\nТехническим языком: вид тестирования, направленный на определение поведения системы при эмуляции многих пользователей в ней\nДля инженера: Разработка Методики нагрузочного тестирования, Подготовка скриптов, эмулирующих действия реальных пользователей, Подготовка сценариев пользователя, Подготовка мониторинга, Анализ полученных данных тестирования и формирование скриптов"
    },
    {
        block: "JMETER",
        question: "Главная/основная задача НТ?",
        answer: "Эмуляция действий реального пользователя"
    },
    {
        block: "JMETER",
        question: "Цели НТ? От чего зависят?",
        answer: "Цели НТ зависят от события, которое инициирует НТ, например:\nВыпуск нового ПО (продукт с нуля)\nДоработка эксплуатируемого ПО (добавление нового функционала)\nИнциденты/проблемы при эксплуатации (баги (упал сервер))\nРасширение бизнеса (планируется увеличение нагрузки)"
    },
    {
        block: "JMETER",
        question: "Цели для каждого события? (см. вопрос №3)",
        answer: "Выпуск нового ПО: Определение максимальной производительности системы, проверка на работоспособность при целевой нагрузке, выявление дефектов, определение узких мест\nДоработка эксплуатируемого ПО: Сравнение результатов на предыдущей версии, Обеспечение неухудшения производительности\nИнциденты/проблемы при эксплуатации: Воспроизведение ситуаций ошибок при эксплуатации на тестовом стенде, Анализ появления ошибок, Предоставления рекомендаций для устранения проблем\nРасширение бизнеса: Определение максимальной производительности системы, Проверка работы на целевой нагрузке, Определение узких мест"
    },
    {
        block: "JMETER",
        question: "Этапы НТ?",
        answer: "1. Постановка задачи\n2. Подготовка стенда: Сравнение с промышленным стендом, Приведение к промышленному стенду, Настройка мониторинга\n3. Подготовка методики нагрузочного тестирования\n4. Расчет профиля НТ\n5. Разработка средств НТ\n6. Проведение тестов"
    },
    {
        block: "JMETER",
        question: "Промышленный и тестовый стенды?",
        answer: "Промышленный стенд: пространство, которое выводится в продуктивную зону, где им будут пользоваться пользователи\nТестовый стенд: на этом стенде проводятся все тесты, накатываются обновления, доработки, положительный результат переносится на промышленную среду"
    },
    {
        block: "JMETER",
        question: "Основное отличие тестового стенда от промышленного?",
        answer: "В тестовый стенд можно не включать какой-либо функционал, потому что для тестирования он нам не нужен, а также заменить его заглушкой, чтобы не поломать работу системы"
    },
    {
        block: "JMETER",
        question: "Набор стандартных тестов?",
        answer: "Быстрый поиск максимума – плавно повышаем нагрузку от нуля до заведомо большего значения. Останавливаем тест при нарушении какого-либо показателя. Запускается на короткое количество времени. Делается для того чтобы легче\nПоиск максимальной производительности проводится из двух частей:\n1. Подготовка: Проводится быстрый поиск максимума, Фиксируется примерная максимальная пропускная способность, умноженная на 1.2 на 100% - предполагаемая максимальная нагрузка, Формируется шаг нагрузки – 10% от предполагаемой максимальной нагрузки\n2. Тест: Подается нагрузка интенсивностью в один шаг, Увеличивается на шаг через фиксированное время (например 10 минут) до достижения предполагаемой максимальной нагрузки, При нарушении одного или нескольких показателей на определенной ступени останавливаем тест, Фиксируется максимальная производительность интенсивности предыдущего шага\n3. Цель: Определить максимальную нагрузку, Выявить проблемы с производительностью, Определить узкие места\nБазовый профиль:\n1. Подготовка: Определяются бизнес требования в части пропускной способности как целевая нагрузка, Определяется скорость входа пользователей, чтобы система не деградировала от резкого скачка нагрузки\n2. Тест: Увеличиваем нагрузку от нуля до целевого значения, Держим нагрузку в течении 1-3 часов\n3. Цель: Проверка работы на целевой нагрузки\nТест надежности\n1. Подготовка: Определяется интенсивность нагрузки как 70-80% от максимальной производительности системы как нагрузка надежности\n2. Тест: Увеличиваем нагрузку от нуля до целевого значения нагрузки надежности, Держим нагрузку в течении 24-48 часов\n3. Цель: Проверка работы при длительной нагрузке, Распространенная цель теста надежности – это проверка на утечку памяти. Утечка памяти – это постепенный рост утилизации оперативной памяти при работе приложения. Превышение утилизации памяти максимального лимита приводит к остановке приложения по ошибке OutOfMemory.\nОтказоустойчивость (дополнительный тест) какого-либо элемента архитектуры\n1. Подготовка: Запускается тест интенсивностью нагрузки надежности (все зависит от пожелания заказчиков, интенсивность может варьироваться)\n2. Тест: Отключаем элемент (например БД) на 15 минут, Восстанавливаем работу\n3. Цель: Подготовить разработчиков к неожиданным инцидентам, Проверить работоспособность при недоступности, Замерить время восстановления после аварии\nРезкий вход пользователей (дополнительный тест)\n1. Подготовка: Запускается тест интенсивностью нагрузки надежности (все зависит от пожелания заказчиков, интенсивность может варьироваться)\n2. Тест: Отключаем элемент (например БД) на 15 минут, Восстанавливаем работу\n3. Цель: Подготовить разработчиков к неожиданным инцидентам, Проверить работоспособность при недоступности, Замерить время восстановления после аварии\nОбъемное тестирование"
    },
    {
        block: "JMETER",
        question: "Что такое утилизация?",
        answer: "Утилизация – это использование, например, есть лимит по ОС 16Г, приложение использовало 8Г, то есть мы утилизировали на 50%."
    },
    {
        block: "JMETER",
        question: "Критерии нагрузочного тестирования",
        answer: "Основные критерии производительности:\nПропускная способность – количество операций в единицу времени. Определяется для каждой системы индивидуально. Это основной показатель производительность системы.\nВремя отклика – время ожидания пользователем на запросы. Обычно фиксируется как SLA (Service Level Agreement, т.е. соглашение о том сколько конкретный запрос или операция выполняются). Во время теста это будет стоп-фактор для остановки по причине неудовлетворения бизнес-требованиям.\nПроцент успешных операций в системе (обычно принимается за 95%, но sla могут зависеть от запросов бизнеса). Для некоторых систем каждая операция является бизнес критичной, поэтому приемлемое количество успешных операций стоит оговорить.\nУтилизация ресурсов архитектурных элементов (обычно принимается как 80%, но sla могут зависеть от запросов бизнеса). Для некоторых систем есть свои требования по части утилизации ресурсов, например процент утилизации контактов к БД не должен превышать 70%."
    },
    {
        block: "JMETER",
        question: "Когда останавливать тест?",
        answer: "Если время отклика какой-либо операции превышает SLA\nЕсли процент ошибок ошибочных операций превышает 5%\nЕсли ресурсы системы утилизируются более чем на 80%\nНужно помнить, что каждая система индивидуальна, критерии производительности проговариваются с заказчиков"
    },
    {
        block: "JMETER",
        question: "Профиль НТ это?",
        answer: "Простыми словами: таблица из двух столбцов, название операции и целевая интенсивность\nТехническим языком: это набор операций и их интенсивности, подобранные таким образом, чтобы в совокупности они создавали целевую нагрузку"
    },
    {
        block: "JMETER",
        question: "Скрипт это?",
        answer: "Это техническое название действий который выполняет реальный пользователь"
    },
    {
        block: "JMETER",
        question: "Источники для профиля НТ",
        answer: "Логи приложения на ПРОМе:\nПолучить логи: все приложения логируют входящие запросы, и из этой информации можно получить информацию о частоте каждого вызова\nГде взять: запросить у людей, сопровождающих промышленную эксплуатацию\nПримечания: после получения логов требуется провести анализ, т.е. нужно написать скрипт для парсинга логов\nСтатистика БД\nПочему БД: Многие приложения логируют важную информацию БД, например, количество купленных товаров или проведенных бизнес транзакций\nГде взять: запросить у людей, сопровождающих промышленную эксплуатацию\nПримечания: полученную информацию требуется проанализировать и разобраться, какой операцией могла быть создана та или иная запись в БД\nАналитика команды\nПочему аналитика: часто команда держит аналитиков, которые занимаются частотой выполняемых бизнес операций\nГде взять: задача сводится только к обращению к специалистам\nПримечания: не требуется дополнительных действий\nБизнес требования\nПочему аналитика: можно в профиль НТ вносить бизнес требования системы\nГде взять: запросить БТ у команды\nПримечания: нужно иметь ввиду, что эти операции могут отличаться от фактических и быть основаны на планируемой нагрузке, а не на фактической"
    },
    {
        block: "JMETER",
        question: "Критерии выбора операций в профиль НТ",
        answer: "Необходимо минимизировать количество операций, для ускорения работы.\nОсновные критерии:\nИнтенсивность операции (пользователем)\nКритичность (на сколько важно для бизнеса)\nТрудозатратность\nМодель нагрузки (ночной, дневной профиль)"
    },
    {
        block: "JMETER",
        question: "Сценарий НТ",
        answer: "Это совокупность параметров, необходимые используемому инструменту для подачи нагрузки согласно профилю НТ. Это как бы характер теста.\nБазовые параметры:\nПараметр, отвечающий за частоту операций одного пользователя\nPacing (LoadRunner)\nTPM количество операций в минуту (Jmeter)\nКоличество пользователей"
    },
    {
        block: "JMETER",
        question: "Рассчет операций в секунду и расчет нагрузки",
        answer: "Расчет операций в секунду = 60сек/время выполнени я операции\nРасчет нагрузки = операций в секунду * кол-во VUS * время ступени"
    },
    {
        block: "JMETER",
        question: "Многопоточность",
        answer: "Эмуляция нескольких пользователей с одними и теми же действиями"
    },
    {
        block: "JMETER",
        question: "Thread",
        answer: "Пользователь"
    },
    {
        block: "JMETER",
        question: "Paicing",
        answer: "Время выделенное на прохождение одной итерации. Время между итерациями, позволяет сделать запас времени, выставляется на x2 от времени пользователя воизбежании накладывания итераций\nЗначение должно быть больше времени выполнения скрипта\nЧем больше значение пейсинга, тем больше потратиться виртуальных пользователей\nЕсли время работы скрипта во время теста превышает пейсинг то этот тест считается не валидным. Увеличение числа виртуальных пользователей ведет к увеличению ресурсов генераторов нагрузки. С помощью параметра пейсинг инженер НТ контролирует количество операций который пройдет один вузер за единицу времени"
    },
    {
        block: "JMETER",
        question: "TPM",
        answer: "Количество прохождений скрипта за 1 минуту (transaction perminute). ТРМ так же назначается инженером НТ и должен исходить из условий:\nЗначение должно быть рассчитано на основании времени прохождения скрипта\nЧем меньше ТРМ назначен, тем больше потребуется виртуальных пользователей\nТРМ должно быть меньше количества прохождения скрипта без нагрузки. Увеличивая количество виртуальных пользователей, ведет к увеличению ресурсов генераторов нагрузки."
    },
    {
        block: "JMETER",
        question: "Что такое мониторинг?",
        answer: "Постоянное наблюдение за каким-либо процессом для оценки их состояния и прогнозов развития. Это средство с помощью которого мы говорим все ли в порядке с системой под нагрузкой"
    },
    {
        block: "JMETER",
        question: "Какие основные метрики?",
        answer: "• CPU – процессор, это мозг машины, он совершает все логические операции, чем больше операций совершается процессор, тем больше он загружен\nОписывается:\n- Утилизация процессора (в т.ч. отдельным процессором)\n- Процессорная очередь\n- Количество процессорных покрываний в секунду\n- Количество переключений контекста в секунду\nОперативная память – быстрое хранилище в котором хранятся все процессы\nОписывается:\n- Свободная память\n- Скорость страничного обмена\n- Использование файла подкачки\nДиск – долговременное хранилище данных. Запись на диск обычно в 10 раз дольше, чем хранение в оперативной памяти\nОписывается:\n- Средний размер очереди чтения/записи по каждому диску в отдельности\n- Количество операций чтения/записи в секунду по каждому диску в отдельности\n- Время доступа к дисковой подсистемы\n• Сеть – сетевой интерфейс, размер отправляемых и получаемых данных."
    },
    {
        block: "JMETER",
        question: "Что такое МНТ?",
        answer: "Методика нагрузочного тестирования – единый документ, который полностью описывает все вводные проекта, отвечает на вопросы, что, где, когда и как проводится тестирование конкретной системы."
    },
    {
        block: "JMETER",
        question: "Причины написания МНТ",
        answer: "• Причина бюрократическая: написание МНТ - это частое требование заказчиков, оно вызвано требованиями выдать документ, который будет регулировать планируемые действия\n• Причина менеджерская: частое требования менеджера, который понимает, что тестирование, которое проводим должно быть выполнено любым другим работником. Т.е. для передачи дел другому инженеру\n• Причина инженерская: должно быть личным желанием инженера НТ сформировать полное, структурированное понимание о системе. Самому зафиксировать цели и планы чтобы не упустить важных договоренностей с командой разработки и менеджерами во время тестирования"
    },
    {
        block: "JMETER",
        question: "Что такое мониторинг?",
        answer: "Постоянное наблюдение за каким-либо процессом для оценки их состояния и прогнозов развития. Это средство с помощью которого мы говорим все ли в порядке с системой под нагрузкой."
    },
    {
        block: "JMETER",
        question: "Какие основные метрики?",
        answer: "• CPU – процессор, это мозг машины, он совершает все логические операции, чем больше операций совершается процессор, тем больше он загружен\n\nОписывается:\n- Утилизация процессора (в т.ч. отдельным процессором)\n- Процессорная очередь\n- Количество процессорных покрываний в секунду\n- Количество переключений контекста в секунду\n\nОперативная память (RAM) – быстрое хранилище в котором хранятся все процессы\n\nОписывается:\n- Свободная память\n- Скорость страничного обмена\n- Использование файла подкачки\n- Так же результаты утечки памяти можно смотреть на графике Heap/Metaspace\n\nДиск (I/O) – долговременное хранилище данных. Запись на диск обычно в 10 раз дольше, чем хранение в оперативной памяти\n\nОписывается:\n- Средний размер очереди чтения/записи по каждому диску в отдельности\n- Количество операций чтения/записи в секунду по каждому диску в отдельности\n- Время доступа к дисковой подсистемы\n\n• Сеть (Network) – сетевой интерфейс, размер отправляемых и получаемых данных. Можем упереться в сеть в том случае, если объем данных, который мы отправляем превышает пропускную способность канала.\n\n• System Load – измеряют какая нагрузка подавалась в течении 1 мин, 5 мин, 15 мин\n\n• Время отклика – обычно SLA 2.5 секунды (есть запросы которые обрабатываются дольше)"
    },
    {
        block: "JMETER",
        question: "Какие метрики приложения есть?",
        answer: "• Threads - потоки\n• Memory – ОС (например джава много ест ресурсов ОС)\n• Garbage Collector – сборщик мусора\n• Информация по выполнению запросов"
    },
    {
        block: "JMETER",
        question: "Какая есть группа приложений/связка для мониторинга?",
        answer: "• Exporter – приложение для сбора метрик. Существует множество типов экспортеров:\n- Node Exporter – сбор метрик с самого сервера, дает основные метрики (ЦПУ, нетворк, сеть, диск)\n- Actuator exporter – сбор метрик с приложения, дает метрики с приложения (Garbage Collector, коннекты к БД, HTTP статистика, данные о контейнерах, данные о логах)\n- Kafka Exporter - Собирает различные метрики о работе Kafka, такие как задержка сообщений, состояние потребителей, состояние брокеров\n- PostgreSQL Exporter - Собирает различные метрики о работе PostgreSQL, такие как количество запросов, использование ресурсов, состояние индексов\n• Prometheus server – БД временных рядов для сбора и хранения метрик Exporter-ов. Мониторит самые разные системы: БД, серверы, отдельные виртуальные машины и т.д.\n• Grafana – приложение для визуализации метрик, собираемых Prometheus server и Exporter"
    },
    {
        block: "JMETER",
        question: "RPS это?",
        answer: "Число запросов в секунду на страницы сайта, которые производились при нагрузочном тестировании."
    },
    {
        block: "JMETER",
        question: "Запуск Jmeter без графического режима (non-GUI)",
        answer: "jmeter -n -t D:\\TestScripts\\script.jmx -l D:\\TestScripts\\scriptresults.jtl, где:\n• -n – параметр, при котором запускается NON-GUI режим;\n• -t – путь до вашего тест плана в формате .JMX;\n• -l – место, куда запишется файл формата .JTL с результатами прохождения тестового сценария."
    },
    {
        block: "JMETER",
        question: "Главное окно Jmeter",
        answer: "• В левой части находится рабочее поле программы, представляющее собой древовидную структуру, которая берет начало из основного узла – TestPlan (тестовый план).\n• В план тестирования основных его элементов, список которых можно увидеть, вызвав его контекстное меню и наведя курсор на кнопку Add.\n• Сверху находится панель инструментов, на которой расположены кнопки и индикаторы, помогающие оперировать ходом создания и прохождения теста. К числу основных можно отнести следующие:"
    },
    {
        block: "JMETER",
        question: "Логирование в JMeter",
        answer: "Сам лог-файл, в который записывается информация во время прохождения теста, называется jmeter.log. В графическом интерфейсе JMeter существует специальная панель для просмотра логов, в которой отображаются все события во время прохождения текущего тестового плана. Для ее вызова необходимо нажать на иконку.\n\nСобытия записываются в журнал согласно уровням. Существует несколько уровней логирования:\n• ERROR – содержит информацию об ошибках элемента тестового плана во время его прохождения и самого JMeter.\n• WARN – содержит информацию о событиях предупреждений.\n• INFO – записываются информационные события.\n• DEBUG – записываются события отладки.\n• TRACE – записываются все события."
    },
    {
        block: "JMETER",
        question: "Структура тестового плана",
        answer: "1. Thread Group - основной рабочий элемент, в который записываются сценарии, добавляется различная логика и элементы управления, участвующие в тесте. Элемент Thread Group, позволяющий задавать параметры генерируемой на приложение нагрузки, находится в категории Threads. Основными его параметрами являются Action to be taken after a Sample Error, Thread Properties, Scheduler Configuration.\n\n2. Thread Properties - Данная панель позволяет настроить эмулируемую приложением нагрузку:\n• Number of threads – количество эмулируемых пользователей, одновременно работающих с приложением.\n• Ramp-up period – промежуток времени, через который выполняется запуск очередного потока (например, если указать Number of threads = 10, а Ramp-up period = 100, то это будет означать, что каждые 10 секунд будет запускаться новый поток).\n• Loop count – количество циклов, в течение которых будет выполняться сценарий внутри Thread Group (Forever – сценарий будет выполняться всегда, пока не будет прерван явно).\n• Scheduler – планировщик времени работы сценария."
    },
    {
        block: "JMETER",
        question: "Элементы конфигурации",
        answer: "Элементы конфигурации (Configuration Elements) позволяют задавать глобальные настройки для всего тестового плана, а также объявлять переменные, данные из которых впоследствии уже будут. Настройки элементов конфигурации можно использовать как для всего сценария, определив его в начале тестового плана, так и для определенных частей плана, разместив его внутри конкретного контроллера или сэмплера. К числу наиболее важных элементов относятся следующие:\n• CSV Data Set Config\n• HTTP Request Defaults\n• User Defined Variables\n• HTTP Header Manager\n• JDBC Connection Configuration\n• HTTP Cache Manager\n• HTTP Cookie Manager\n• FTP Request Defaults\n• Counter"
    },
    {
        block: "JMETER",
        question: "HTTP Request Defaults",
        answer: "Элемент HTTP Request Defaults позволяет задать параметры соединения с веб-сервером по умолчанию, которые будут использоваться во всех элементах HTTP Request Sampler при условии, что в них не задано своих настроек.\n• Web Server – необходимо указать тип протокола, доменное имя / IP адрес и порт веб-сервера.\n• Content encoding – необходимо ввести стандарт кодирования текста. Желательно использовать UTF-8 (Юникод).\n• Send Parameters With the Request – в данном поле определяются параметры, которые будут отправлены в каждом HTTP Request Sampler."
    },
    {
        block: "JMETER",
        question: "User Defined Variables",
        answer: "Элемент User Defined Variables (UDV) позволяет задать набор глобальных переменных и их значения по умолчанию, которые будут использованы в тестовом плане.\nПанель User Defined Variables:\n• Name – имя переменной для обращения к ней в тесте.\n• Value – значение переменной.\n• Description – описание переменной. Данное поле используется в информационных целях, его необходимо заполнять для большей прозрачности и более легкого восприятия вашего тестового плана."
    },
    {
        block: "JMETER",
        question: "HTTP Header Manager",
        answer: "Элемент HTTP Header Manager позволяет добавлять или переопределять такие заголовки для отправляемого запроса в JMeter."
    },
    {
        block: "JMETER",
        question: "Контроллеры",
        answer: "Контроллеры (Controllers) в JMeter являются элементами логики и предназначены для управления прохождением теста. Всего имеется два типа контроллеров: Сэмплеры (Samplers) и логические контроллеры (Logic Controllers)."
    },
    {
        block: "JMETER",
        question: "Сэмплеры",
        answer: "Сэмплеры (Samplers) используются для обращения Jmeter к серверу путем отправки запросов. Сэмплеры, по сути, это реальные запросы, которые Jmeter отправляет на тестируемый веб-сервер. Каждый сэмплер генерирует один или несколько результатов, которые имеют определенные атрибуты (успех/неудача, время выполнения, размер данных и т.д.) и могут быть отображены в различных листенерах. К числу наиболее важных сэмплеров относятся:\n• HTTP Request\n• FTP Request\n• SMTP Sampler\n• JDBC Request\n• Debug Sampler"
    },
    {
        block: "JMETER",
        question: "HTTP Request",
        answer: "HTTP Request Sampler используется для отправки HTTP/HTTPS запросов на веб-сервер.\n• Панель Web Server – необходимо ввести тип протокола, ввести доменное имя / IP-адрес веб-сервера и порт сервера.\n• Панель HTTP Request – необходимо выбрать метод запроса, ввести путь к запрашиваемому ресурсу.\n• Send Parameters With the Request – в данном поле определяются параметры, отправляемые в запросе."
    },
    {
        block: "JMETER",
        question: "Логические контроллеры",
        answer: "Логический контроллер (Logic Controller) позволяет выстроить порядок обработки сэмплеров в тестовом плане. Логические контроллеры решают, когда и каким образом отправлять запрос на веб-сервер. Они могут быть размещены только внутри Thread Group. К числу наиболее важных логических контроллеров относятся:\n• Loop Controller – при установке данного параметра находящиеся внутри контроллера элементы будут выполняться бесконечное число раз.\n• Random Controller - позволяет запускать находящиеся внутри него сэмплеры/запросы в случайном порядке для каждого цикла.\n• Recording Controller - В данный элемент будут сохраняться все действия, которые будет записывать элемент HTTP(S) Test Script Recorder (для него Recording Controller используется по умолчанию).\n• RunTime Controller - RunTime Controller контролирует выполнение расположенных внутри сэмплеров/запросов в течение заданного времени.\n• If Controller - IF Controller позволяет задать условие выполнения вложенных в него элементов. По умолчанию условие в элементе If Controller проверяется только один раз при входе в контроллер, но существует настройка, при которой заданное условие будет проверяться для каждого элемента, расположенного внутри него.\n• While Controller - While Controller позволяет задать поведение тестового плана, которое происходит при определенном условии и лучше всего подходит для сложных сценариев, которые имитируют реалистичное поведение пользователя. Элементы внутри контроллера выполняются ноль, один или несколько раз в зависимости от того, сколько раз выполняется заданное в нем условие.\n• Simple Controller - Simple Controller предназначен для хранения сэмплеров и других логических контроллеров в заданном порядке. В этом заключается его основная задача и, по сравнению с другими контроллерами, другой функциональности он не имеет."
    },
    {
        block: "JMETER",
        question: "Препроцессоры",
        answer: "Препроцессоры (Pre-Processor) – это элементы Jmeter, которые используются для выполнения действий до выполнения запросов сэмплера в тестовом сценарии. Препроцессоры могут использоваться для различных задач тестирования производительности, таких как выборка данных из базы данных, установка тайм-аута между выполнением сэмплера или перед генерацией тестовых данных. Среди самых важных препроцессоров можно выделить следующие:\n• BeanShell PreProcessor\n• JSR223 PreProcessor - вариант написания сценариев с использованием препроцессоров. JSR223 (от англ. Java Specification Request – запрос на спецификацию Java) имеет схожую функциональность с BeanShell PreProcessor, однако основное его отличие в том, что вы можете использовать дополнительные языки сценариев, такие как: ecmascript, groovy, java, javascript, jexl и nashorn.\n• JDBC PreProcessor."
    },
    {
        block: "JMETER",
        question: "Пост-обработчики",
        answer: "Пост-обработчики (Post-Processors) – элементы Jmeter, которые выполняются после завершения сэмплеров и используются, главным образом, для обработки данных ответа сервера и извлечения конкретного значения разметки для его последующего использования в тесте.\nДалее перечислены наиболее часто используемые пост-обработчики:\n• BeanShell PostProcessor\n• JSR223 PostProcessor\n• JDBC PostProcessor\n• CSS/JQuery Extractor\n• Xpath Extractor\n• Regular Expression Extractor - Регулярные выражения (англ. regular expressions) – формальный язык поиска и осуществления манипуляций с подстроками в тексте, основанный на использовании метасимволов, которые указывают, что должна быть найдена некоторая необычная вещь, или влияют на другие части регулярного выражения, повторяя или изменяя их значение.\n• Debug PostProcessor."
    },
    {
        block: "JMETER",
        question: "Таймеры",
        answer: "Для имитации пользовательского ожидания в Jmeter используют таймеры (Timers).\nК числу наиболее важных таймеров относятся:\n• Constant Timer - Элемент Constant Timer применяется для генерации постоянной задержки перед выполнением каждого запроса.\n• Uniform Random Timer\n• Gaussian Random Timer\n• BeanShell Timer"
    },
    {
        block: "JMETER",
        question: "Элементы подтверждения",
        answer: "Элемент подтверждения (Assertion) используются в качестве инструмента проверки в Jmeter.\nК числу наиболее важных элементов подтверждения можно отнести следующие:\n• Response Assertion - Элемент Response Assertion используется для проверки наличия в ответе веб-сервера конкретной строки (шаблона) или определенных полей, таких как код ответа, сообщение ответа и т.д.\n• Size Assertion - Элемент Size Assertion используется в основном, когда необходимо проверить размер ответа целиком или его определенной части, такой как заголовок, код и т.д.\n• Duration Assertion - Элемент Duration Assertion используется, главным образом, когда известно время отклика запроса и, на основании этих данных, необходимо проверить конкретный сэмплер.\n• JSR223 Assertion - является элементом подтверждения, задаваемым с помощью сценария с использованием одного из поддерживаемых языков сценариев, таких как Groovy, BeanShell, java и т.д."
    },
    {
        block: "JMETER",
        question: "Листенеры",
        answer: "Листенеры (listeners) – элементы тестового плана, которые используются для просмотра и анализа информации, собранной JMeter во время прохождения теста, в табличной или графической форме.\n1. Листенер Summary Report собирает данные из всех сэмплеров, находящихся в Thread Group.\n2. Листенер Aggregate Report собирает данные из сэмплеров, находящихся в логическом контроллере Start Process.\n3. Листенер View Result Tree собирает данные из всех сэмплеров текущего тестового плана."
    },
    {
        block: "JMETER",
        question: "Порядок выполнения элементов",
        answer: "Элементы тестового плана Jmeter имеют следующий порядок выполнения:\n1. Элементы конфигурации.\n2. Препроцессоры.\n3. Таймеры.\n4. Сэмплеры.\n5. Пост-обработчики (если результат выполнения сэмплера не null).\n6. Элементы подтверждения (если результат выполнения сэмплера не null)\n7. Листенеры (если результат выполнения сэмплера не null)"
    },
    {
        block: "AРХИТЕКТУРА",
        question: "Типы архитектур",
        answer: "Стандартно ИС включается в себя 3 компонента:\n• Управление данными\n• Бизнес-логику\n• Пользовательский интерфейс."
    },
    {
        block: "AРХИТЕКТУРА",
        question: "Файл-серверная архитектура",
        answer: "Данная архитектура систем БД предполагает выделение одной из машин сети в качестве центральной (сервер файлов). На такой машине хранится совместно используемая централизованная БД."
    },
    {
        block: "AРХИТЕКТУРА",
        question: "Двухуровневая архитектура",
        answer: "Клиент-серверная архитектура - архитектура, в которой задания или сетевая нагрузка распределены между поставщиками услуг, называемыми серверами, и заказчиками услуг, называемыми клиентами."
    },
    {
        block: "AРХИТЕКТУРА",
        question: "Трехуровневая архитектура",
        answer: "Архитектурная модель программного комплекса, предполагающая наличие в нём трёх типов компонентов клиентских приложений (с которыми работают пользователи), серверов приложений (с которыми работают клиентские приложения) и серверов баз данных (с которыми работают серверы приложений)."
    },
    {
        block: "AРХИТЕКТУРА",
        question: "Микросервисная архитектура",
        answer: "Формат проектирования ИС, позволяющий разделять монолитную (весь функционал) ИС на независимые кусочки – микросервисы."
    },
    {
        block: "AРХИТЕКТУРА",
        question: "Типы БД",
        answer: "• Реляционные базы данных:\n  o Oracle - реляционная\n  o MySQL - реляционная\n  o Microsoft SQL Server – реляционная\n  o PostgreSQL - реляционная\n\nВ данном типе БД используются следующие связи (relation):\n  • Многие ко многим (необходима промежуточная таблица)\n  • Один ко многим (с обязательной связью; с необязательной связью)\n  • Один к одному (с обязательной связью; с необязательной связью)\n\n• Key-value (ключ-значение) базы данных - Тип баз данных Key-value предназначен для осуществления быстрых, почти мгновенных запросов для таких задач как кэш (временные файлы для быстрого доступа), отображение баланса и т.д. Высокая скорость осуществляется за счет хранения данных по принципу ключ-значение, и в большинстве случаев благодаря работе в оперативной памяти.\n  o Строки (strings). Базовый тип данных Redis. Строки в Redis бинарно-безопасны, могут использоваться так же как числа, ограничены размером 512Мб.\n  o Списки (lists). Классические списки строк, упорядоченные в порядке вставки, которая возможна как со стороны головы, так и со стороны хвоста списка.\n  o Множества (sets). Множества строк в математическом понимании: не упорядочены, поддерживают операции вставки, проверки вхождения элемента, пересечения и разницы множеств.\n\n• Документо-ориентированные базы данных - Документо-ориентированные базы данных созданы для хранения иерархических структур данных (документов). Документ представляет собой набор атрибутов (ключ и соответствующее ему значение). Значения могут быть как и простыми типами данных (строки, числа или даты), так и более сложными, такими как вложенные объекты, массивы и ссылки на другие документы.\n\n• Базы данных временных рядов - Если у вас есть упорядоченные по времени данные с временными метками, такие как метрики от инфраструктуры или данные датчиков, может быть полезно использовать одну из баз данных временных рядов. Пример таких БД:\n  • Prometheus\n  • InfluxDB\n\n• Поисковые базы данных (Search Engines) - Позволяют осуществлять поиск большим объемам данных, Например огромного кол-ва логов, то вам может пригодиться использовать базу данных, совмещающую с функционалом хранения информации еще и функционал поиска по текстам. Наиболее популярны такие решения как Elasticsearch (и его версия - OpenSearch).\n\n• Графовая база данных – это нереляционный тип баз данных (NoSQL), основанный на топографической структуре сети. Графы представляют наборы данных в виде узлов, ребер и свойств.\n  o Узлы, или точки (nodes) – это сущности данных; ими является любой объект, который вы планируете отслеживать. Например, люди, заказчики, подразделения и т.д.\n  o Ребра, или линии (edges) – отображают взаимосвязь между узлами. Эти связи имеют направление и могут быть одно- или двунаправленными.\n  o Свойства (properties) содержат описательную информацию, связанную с узлами. В некоторых случаях свойства бывают и у ребер."
    },
    {
        block: "АРХИТЕКТУРА",
        question: "Брокеры сообщений",
        answer: "Брокер сообщений представляет собой тип построения архитектуры, при котором элементы системы «общаются» друг с другом с помощью посредника. Благодаря его работе происходит снятие нагрузки с веб-сервисов, так как им не приходится заниматься пересылкой сообщений: всю сопутствующую этому процессу работу он берёт на себя. Можно сказать, что в работе любого брокера сообщений используются две основные сущности: producer (издатель сообщений) и consumer (потребитель/подписчик)."
    },
    {
        block: "АРХИТЕКТУРА",
        question: "Типы брокеров сообщений",
        answer: "• Apache Kafka\n  o Producer (источник) отправляет сообщения в брокер\n  o Consumer (Потребитель) вычитывает эти сообщения самостоятельно\n  o Partition (Партиция) хранит сообщения и отдаёт их подписанным получателям\n• RabbitMQ\n• Apache ActiveMQ\n• Apache Artemis"
    },
    {
        block: "АРХИТЕКТУРА",
        question: "Синхронная передача сообщений",
        answer: "Синхронное взаимодействие — Оно все детали удаленного вызова, что для вызывающего сервиса превращается в обычный вызов функции с получением ответа."
    },
    {
        block: "АРХИТЕКТУРА",
        question: "Асинхронная передача сообщений",
        answer: "Асинхронное взаимодействие предполагает, что вы посылаете сообщение, которое будет обработано когда-нибудь позднее. Достаточно часто статус нужен для того, чтобы продолжить обработку."
    },
    {
        block: "АРХИТЕКТУРА",
        question: "Виртуальные сервера",
        answer: "Виртуальная машина (ВМ или VM) — это виртуальный компьютер, который использует выделенные ресурсы реального компьютера (процессор, диск, память). Эти ресурсы хранятся в облаке и позволяют ВМ работать автономно."
    },
    {
        block: "АРХИТЕКТУРА",
        question: "Контейнеризация",
        answer: "Альтернативным подходом к изоляции приложений являются контейнеры. Идея состоит в том, чтобы в рамках одной ОС выделить изолированную область и запускать в ней приложение. В этом случае говорим о виртуализации на уровне ОС. В отличие от ВМ контейнеры изолированно используют свой кусочек ОС."
    },
    {
        block: "АРХИТЕКТУРА",
        question: "Docker",
        answer: "Приложение, запущенное в контейнере думает, что оно одно во всей ОС. Изоляция достигается за счет использования таких Linux-механизмов, как namespaces и control groups. Namespaces обеспечивают изоляцию в рамках ОС. Control groups устанавливают лимиты на потребление контейнером ресурсов хоста, чтобы сбалансировать распределение ресурсов между запущенными контейнерами.\n\n• Контейнеры: Альтернативным подходом к изоляции приложений являются контейнеры. Само понятие контейнеров не ново и давно известно в Linux. Идея состоит в том, чтобы в рамках одной ОС выделить изолированную область и запускать в ней приложение. В этом случае говорим о виртуализации на уровне ОС. В отличие от ВМ контейнеры изолированно используют свой кусочек ОС:\n  o дерево процессов\n  o сетевые интерфейсы\n  o файловая система\n\n• Образы (image): Образ в первом приближении можно рассматривать как набор файлов. В состав образа входит все необходимое для запуска и работы приложения на голой машине с докером: ОС, среда выполнения и приложение, готовое к развертыванию. Образ состоит из слоев, каждый из которых представляет собой неизменяемую файловую систему, а по-простому набор файлов и директорий. Образ в целом представляет собой объединенную файловую систему (Union File System), которую можно рассматривать как результат слияния файловых систем слоев. Объединенная файловая система умеет обрабатывать конфликты, например, когда в разных слоях присутствуют файлы и директории с одинаковыми именами. Каждый следующий слой добавляет или удаляет какие-то файлы из предыдущих слоев."
    },
    {
        block: "АРХИТЕКТУРА",
        question: "Kubernetes",
        answer: "Kubernetes является проектом с открытым исходным кодом, предназначенным для управления кластером контейнеров Linux как единой системой. Kubernetes управляет и запускает контейнеры Docker на большом количестве хостов, а так же обеспечивает совместное размещение и репликацию большого количества контейнеров.\n\n• Nodes (node.md): Нода это машина в кластере Kubernetes.\n• Pods (pods.md): Pod это группа контейнеров с общими разделами, запускаемых как единое целое.\n• Replication Controllers (replication-controller.md): replication controller гарантирует, что определенное количество «реплик» pod'ы будут запущены в любой момент времени.\n• Services (services.md): Сервис в Kubernetes это абстракция которая определяет логический объединённый набор pod и политику доступа к ним.\n• Volumes (volumes.md): Volume (раздел) это директория, возможно, с данными в ней, которая доступна в контейнере.\n• Labels (labels.md): Label'ы это пары ключ/значение которые прикрепляются к объектам, например pod'ам. Label'ы могут быть использованы для создания и выбора наборов объектов.\n• Kubectl Command Line Interface (kubectl.md): kubectl интерфейс командной строки для управления Kubernetes."
    },
    {
        block: "АРХИТЕКТУРА",
        question: "Openshift",
        answer: "Kubernetes – это сердце платформы OpenShift И это на 100% сертифицированный Kubernetes, с полностью открытым кодом и без малейшей проприетарности. Вкратце:\n– API для кластера OpenShift – это стопроцентный Kubernetes.\n– Если контейнер работает в любой другой системе Kubernetes, то он без каких-либо изменений будет работать и на OpenShift. Вносить изменения в приложения не нужно."
    },
    {
        block: "АРХИТЕКТУРА",
        question: "Разница между Openshift и Kubernetes",
         answer: "Kubernetes - это система для автоматизации развёртывания, масштабирования и управления контейнерными приложениями. OpenShift - это платформа, построенная на основе Kubernetes, которая предоставляет дополнительные функции и удобства для разработчиков и администраторов. Основные отличия:\n1. OpenShift включает Kubernetes и добавляет дополнительные инструменты для разработки и управления.\n2. OpenShift имеет удобный веб-интерфейс и командные утилиты для работы с кластером.\n3. OpenShift предоставляет встроенные решения для CI/CD, а также более строгую безопасность и контроль доступа.\nТаким образом, OpenShift расширяет возможности Kubernetes, делая его более удобным и функциональным для корпоративного использования."
    },
    {
        block: "АРХИТЕКТУРА",
        question: "Что такое LoadRunner?",
        answer: "HP LoadRunner (также HPE LoadRunner) — утилита для автоматизированного нагрузочного тестирования. Это хорошо продуманный комплекс для нагрузочного тестирования. Он может:\n- автоматически записывать скрипты\n- подавать нагрузку (50 пользователей бесплатно)\n- анализировать пропускную способность, время ответа и успешные операции.\n\nVuGen - программа для записи скриптов\nController - программа для подачи нагрузки\nAnalysis - программа для анализа результатов"
      },
      {
        block: "АРХИТЕКТУРА",
        question: "Virtual User Generator (VuGen) Структура скрипта",
        answer: "Для просмотра структуры нажать: View → Solution Explorer\n- Actions\n  - vuser_init - воспроизводится скрипт\n  - action - в бесконечном цикле (до времени окончания теста) воспроизводится\n  - vuser_end - воспроизводится скрипт\n- Extra Files\n- Runtime Settings\n- Parameters\n- Recording report\n- Replay Summary\n\nВесь скрипт описывается в Actions. Работа одного пользователя такая:\n- воспроизводится скрипт vuser_init\n- в бесконечном цикле (до времени окончания теста) воспроизводится action\n- воспроизводится скрипт vuser_end"
      },
      {
        block: "АРХИТЕКТУРА",
        question: "Virtual User Generator (VuGen) Parameters",
        answer: "В скрипте есть указания на переменные, они создаются в Parameters. При создании параметра нужно понимать, как он будет использоваться и указывать: тип параметра (File, Custom, Random Number, etc.). В зависимости от типа параметра настройка будет разная. Возьмем самый распространенный тип File. Тип параметра File говорит, что мы берем пул данных (например, список пользователей и паролей). В один файл данных могут входить несколько разных параметров. Пример: У нас есть 1 файл logopass.dat и 2 параметра user & pass. Параметры настройки:\n- Select column (by number, by name) - указание на столбец для считывания параметра\n- File Format (delimiter, first line) - настройка чтения файла (first line может быть удобно при отладке)\n- Select next row (Sequential, Random, Unique, same line as) - условие, как будет выбираться следующее значение\n- Update value on (Each iteration, Each occurrence, once) - настройка, когда менять значение параметра\n- When out of value (abort user, last value, cyclic) - что делать при окончании списка\n- Allocating - распределение параметров по виртуальным пользователям (только для Unique)"
      },
      {
        block: "АРХИТЕКТУРА",
        question: "Virtual User Generator (VuGen) Runtime Settings",
        answer: "Основные настройки сценария:\n- Run Logic - основная логика, какие транзакции как будут выполняться\n- Pacing - настройка пейсига\n- Log - настройка логов\n- Think Time - настройка времени ожидания в скрипте\n- Additional Attributes - добавление параметров без изменения в скрипте\n- Miscellaneous – разное"
      },
      {
        block: "АРХИТЕКТУРА",
        question: "Virtual User Generator (VuGen) Запись Скрипта",
        answer: "Параметры записи:\n- Record into action\n- Record\n- Application\n- URL\n- Recording options показ записи скрипта."
      },
      {
        block: "АРХИТЕКТУРА",
        question: "Функции VuGen",
        answer: "Функции отправки сообщений:\n- web_url - очень простая функция для отправки GET запросов.\n- web_custom_request - функция для отправки http запроса с любым методом\n\nФункции для корреляции:\n- web_reg_save_param_ex - функция для извлечения параметра из ответа используя левую и правую границу\n- web_reg_save_param_regexp - функция для извлечения параметра из ответа используя регулярное выражение\n- web_set_max_html_param_len - функция для увеличения размера считываемого параметра\n\nФункции проверки:\n- web_reg_find - функция проверки вхождения слова в ответ\n\nДругие функции:\n- lr_save_string - сохранение значения в переменной\n- lr_eval_string - преобразование параметра в стринговую переменную\n- lr_output_message - вывод сообщения в консоль"
      },
      {
        block: "АРХИТЕКТУРА",
        question: "Транзакции VuGen",
        answer: "Функции для начала и конца транзакций:\n- lr_start_transaction - начало транзакции\n- lr_end_transaction - конец транзакции\n\nСтатусы окончания транзакции:\n- LR_FAIL - транзакция заканчивается с ошибкой (в независимости от статуса ответов)\n- LR_PASS - транзакция заканчивается успешно (в независимости от статуса ответов)\n- LR_AUTO - статус прохождения транзакции зависит от ошибок от сервера, если нет ошибок, то транзакция прошла."
      },
      {
        block: "АРХИТЕКТУРА",
        question: "Что такое Analysis?",
        answer: "Это приложение для анализа данных, полученных в результате теста. Примечание. Анализирует только метрики с генератора нагрузки и с контролера:\n- Пропускная способность\n- Время отработки транзакций\n- Сколько послали/получили байт за тест\n- Количество vUsers\n\nОсновные действия:\n1. Загрузка данных после теста\n2. Просмотр общего результата\n3. Просмотр основных графиков\n4. Генерация графиков (Merge)\n5. Создание экспресс отчетов\n6. Анализ SLA\n\nОсновной отчет (Summary). Обращаем внимание на:\n- Время теста\n- Суммарное количество пользователей\n- Таблица основных результатов\n\nГрафики. Смотрим в первую очередь на:\n- Running vusers\n- Hits per seconds\n- Average transaction response time\n- Transaction per second"
      },
      {
        block: "МОНИТОРИНГ БД",
        question: "Метрики БД",
        answer: "• Connections (Active Session) - Количество активных соединений к базе данных в данный момент времени.\n• Processes Blocker - Число процессов, блокирующих другие процессы в базе данных.\n• Transactions (Commit and Rollback) - Количество транзакций, завершенных с помощью commit или откатанных с помощью rollback.\n• Change Stats (Select, Insert, Update) - Число операций чтения (select), вставки (insert) и обновления (update) данных в базе данных.\n• Conflict and Lock - Количество конфликтов и блокировок, возникающих при одновременном доступе к данным.\n• Database size - Общий размер базы данных, включая все таблицы и индексы.\n• Processor Queue Length (%) – показывает очередь количество тредов (процессов), которые готовы быть обработаны процессором, но не могут по причине других активных тредов (процессоров)."
      },
      {
        block: "МОНИТОРИНГ БД",
        question: "В чем отличие системных метрик CPU между CPU Usage и CPU System?",
        answer: "CPU Usage:\n• Что это: Общий процент времени, когда процессор занят.\n• Пример: Если CPU Usage = 80%, процессор занят выполнением задач 80% времени.\n• Когда высокое: Когда запущено много программ или задач.\n\nCPU System:\n• Что это: Процент времени, когда процессор занят системными задачами (например, операционной системой).\n• Пример: Если CPU System = 20%, процессор занят операционной системой 20% времени.\n• Когда высокое: Когда операционная система делает много работы, например, обрабатывает прерывания или управляет ресурсами.\n\nВ чем разница:\n• CPU Usage: Включает все задачи (и системные, и пользовательские).\n• CPU System: Включает только системные задачи.\n\nПример:\n• CPU Usage: Высокое, когда много запущенных программ.\n• CPU System: Высокое, когда операционная система активно работает."
      },
      {
        block: "МОНИТОРИНГ БД",
        question: "JVM это?",
        answer: "JVM (Java Virtual Machine) — это виртуальная машина, которая позволяет компьютеру запускать программы, написанные на языке программирования Java и других языках, компилируемых в байт-код Java. Она играет ключевую роль в платформе Java, обеспечивая независимость программного обеспечения от аппаратного обеспечения."
      },
      {
        block: "МОНИТОРИНГ БД",
        question: "Метрики JVM?",
        answer: "• Heap - Область памяти JVM приложений (приложений написанных на Java языке), в которой хранятся объекты\n  o Young Generation Space (Eden Space) – все только что созданные объекты находятся тут\n  o Survivor Space – область памяти для выживших объектов\n  o Old Generation Space – область памяти объектов где объект\n\n• Thread – потоки\n  o Thread live - показывает общее количество активных потоков (не демонов), пользовательские потоки\n  o Thread deamon - показывает общее количество активных потоков (не демонов)\n  o Thread peak - пиковые значение потоков (демоны и не демоны) с момента запуска JVM\n  o Deamon – треды которые обеспечивают работу JVM\n\n• Pause Duration – среднее время «чистки» heap space GC\n  o Minor GC\n  o Major GC"
      },
      {
        block: "МОНИТОРИНГ БД",
        question: "GC и чистка heap",
        answer: "GC (Garbage Collector) – сущность приложений Java, который осуществляет нахождение и удаление объектов в heap space (eden, survivor и old generation space)."
      },{
        block: "МОНИТОРИНГ БД",
        question: "Существующие инструменты анализа производительности",
        answer: "• pg_stat_activity - Текущие активные подключения. Используется для мониторинга активности пользователей и выявления долгих запросов.\n• pg_stat_user_functions - Вызовы пользовательских функций. Помогает в анализе производительности и частоты вызовов пользовательских функций.\n• pg_stat_database - Статистика по базам данных. Используется для общего мониторинга базы данных, включая количество запросов и транзакций.\n• pg_stat_wal - Записи журнала предзаписи (WAL). Помогает в мониторинге процесса записи и архивирования WAL для обеспечения надежности данных.\n• pg_stat_all_indexes - Статистика использования индексов. Используется для оптимизации запросов и определения, какие индексы используются редко или вообще не используются.\n• pg_stat_all_tables - Статистика использования таблиц. Помогает в анализе производительности запросов к таблицам и выявлении узких мест."
      },
      {
        block: "МОНИТОРИНГ БД",
        question: "Часто используемые команды по сборщикам",
        answer: "SELECT datname, usename, now() - xact_start AS TransactionDuration, now() - query_start as QueryDuration FROM pg_stat_activity;\n\nWSEHLERCET ssttaattee, c=o 'uanctt(i*v)e F';\n\nFROM pg_stat_activity GROUP BY state;\n\nSELECT datname, xact_commit + xact_rollback , stats_reset FROM pg_stat_database;"
      },
      {
        block: "МОНИТОРИНГ БД",
        question: "GUI dashboard",
        answer: "В pgAdmin существует собственные dashboard, которые помогают провести первоначальный анализ производительности БД."
      },
      {
        block: "МОНИТОРИНГ БД",
        question: "Explain и Explain Analyze",
        answer: "Explain:\n1. Отображает план запроса, генерируемым планировщиков для оператора.\n2. Показывает ожидаемую стоимость выполнения оператора.\n\nExplain Analyze:\n1. Анализируемый оператор будет выполнен на самом деле.\n2. Отображается реальное время выполнения, включая общее время, затраченное на каждый узел плана в миллисекундах и общее число строк в результате."
      },
      {
        block: "МОНИТОРИНГ БД",
        question: "Что такое память JVM?",
        answer: "• Heap – память, в которой хранятся все объекты, с которым работает Java приложение.\n• Metaspace – область памяти, в которой хранится статическая информация Java приложения.\n• Eden – область памяти молодых объектов.\n• S0, S1 – область памяти «выживших» объектов.\n• Old – область памяти объектов, которые прошли > 15 чисток GC."
      },
      {
        block: "МОНИТОРИНГ БД",
        question: "Что такое heap dump и thread dump",
        answer: "• Heap dump – snapshot (снимок) всех объектов в JVM в конкретный момент времени.\n• Thread dump – snapshot (снимок) всех тредов (потоков) java процессов."
      },
      {
        block: "МОНИТОРИНГ БД",
        question: "В каких ситуациях требуется снятие Heap dumps",
        answer: "Утечка памяти (100% загруженность heap space)."
      },
      {
        block: "МОНИТОРИНГ БД",
        question: "Что такое Threads",
        answer: "Thread – базовый элемент Java приложения, на основе которого формируется концепция многопоточности и параллелизма."
      },
      {
        block: "МОНИТОРИНГ БД",
        question: "В каких ситуациях требуется снятие Thread dumps",
        answer: "Достижение 100% загруженности Thread pool."
      },
      {
        block: "МОНИТОРИНГ БД",
        question: "Проблемы Java приложений",
        answer: "• Утечка памяти - длительный процесс по времени, при котором GC не успевает чистить heap space от ненужных объектов, что приводит к 100% памяти, а следовательно и к деградации тестируемого приложения.\n\nПричины возникновения утечки памяти:\n• Неоптимальная работа GC\n• Недостаточный исходный размер heap space (eden (young generation), survivor и old generation space)\n• Дефект на уровне реализации Java-приложения\n\n100% загруженность пула Threads:\n\nПричины возникновения:\n• Небольшой размер Thread pool - Большое количество thread в статусе running, при условии, что\n• Переход threads в статус waiting/deadlock/time waiting:\n- Приложение ожидает достаточно долго ответа от смежной системы (БД, другие приложения)\n- Само приложение (многопоточное) уходит в состояние deadlock\n\nМалый объем heap space для работы Java приложения."
      },
      {
        block: "МОНИТОРИНГ БД",
        question: "Неоптимальная работа GC",
        answer: "Виды GC:\n• Serial GC - Используется для приложений с малым размером памяти и небольшой нагрузкой.\n• Parallel GC – Осуществляет чистку heap space совместно с работой самого приложения, минимизация времени для работы GC.\n• Concurrent Mark Sweap - Осуществляет в многопоточном режиме чистку heap space. Отличие от parallel, что чистка young и old generation выполняется в multithreading.\n• G1 - В g1 нет четкого разбиения на young и old generation. Вместо этого, каждое поколение объектов – это набор областей памяти (от 1 до 32 Mb)."
      },
      {
        block: "МОНИТОРИНГ БД",
        question: "Оптимизация heap space",
        answer: "• Xmx – устанавливает максимально возможный размер памяти для heap space.\n• Xms – начальный размер выделяемой памяти heap space."
      },
      {
        block: "МОНИТОРИНГ БД",
        question: "Deadlock и его реализация",
        answer: "Deadlock – ситуация, при которой два процесса (потока) находятся в состоянии ожидания ресурсов, занятых друг другом и ни один из них не может продолжать свое выполнение.\n\nПричины deadlock:\n• Недостаток ресурсов\n• Неэффективное взаимодействие\n• Неточное распределение полномочий между потоками\n• Неправильное планирование"
      },
      {
        block: "МОНИТОРИНГ БД",
        question: "Stack",
        answer: "Stack – память в Java используется для распределения статической памяти и выполнения потока. Он содержит примитивные значения, специфичные для метода, и ссылки на объекты, на которые ссылается метод, находящиеся в куче."
      },
      {
        block: "МОНИТОРИНГ БД",
        question: "StackOverFlowError",
        answer: "StackOverFlowError – ошибка, при которой идет переполнение стека выше установленного лимита."
      },
      {
        block: "JAVA",
        question: "Java это",
        answer: "Это строготипизированный ,  объектно-ориентированный язык программирования"
    },
    {
        block: "JAVA",
        question: "ООП это?",
        answer: "Объектно-ориентированный язык программирования (ООП) — это язык программирования, который основывается на концепции 'объектов'. Объекты — это сущности, которые объединяют в себе данные (в виде полей или атрибутов) и методы (функции, которые работают с этими данными).\n\nИнкапсуляция — скрытие внутреннего состояния объекта и предоставление доступа к нему только через методы.\n```java\n// Пример инкапсуляции\npublic class Person {\n    // Приватные поля\n    private String name;\n    private int age;\n\n    // Публичные методы для доступа к полям\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\nНаследование — способность одного класса наследовать поля и методы другого класса.\n```java\n// Базовый класс\npublic class Animal {\n    public void eat() {\n        System.out.println('This animal eats food.');\n    }\n}\n\n// Подкласс, наследующий базовый класс\npublic class Dog extends Animal {\n    public void bark() {\n        System.out.println('The dog barks.');\n    }\n}\n\n// Использование наследования\npublic class Main {\n    public static void main(String[] args) {\n        Dog dog = new Dog();\n        dog.eat(); // Наследованный метод\n        dog.bark(); // Метод подкласса\n    }\n}\n```\nПолиморфизм — возможность объектов разных классов обрабатывать идентичные сообщения (вызывать одинаковые методы) по-своему.\n```java\n// Базовый класс\npublic class Animal {\n    public void makeSound() {\n        System.out.println('Some generic animal sound');\n    }\n}\n\n// Подклассы с переопределением метода makeSound\npublic class Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println('Woof');\n    }\n}\n\npublic class Cat extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println('Meow');\n    }\n}\n\n// Использование полиморфизма\npublic class Main {\n    public static void main(String[] args) {\n        Animal myDog = new Dog();\n        Animal myCat = new Cat();\n        myDog.makeSound(); // Выведет 'Woof'\n        myCat.makeSound(); // Выведет 'Meow'\n    }\n}\n```\nАбстракция - это использование только тех характеристик объекта, которые с достаточной точностью представляют его в данной системе. Основная идея состоит в том, чтобы представить объект минимальным набором полей и методов для решаемой задачи."
    },
    {
        block: "JAVA",
        question: "Строгая типизация в джава это?",
        answer: "Java — строго типизированный язык программирования. Это означает, что каждый переменной и выражению в языке Java присвоен конкретный тип данных, который известен во время компиляции. Типы данных определяют, какие операции могут быть выполнены с переменными и выражениями, а также помогают предотвратить ошибки, связанные с некорректным использованием данных.\n\nПримеры типов данных в Java:\n• Примитивные типы: int, float, double, boolean, char, byte, short, long\n• Ссылочные типы: классы, интерфейсы, массивы\n\nПримеры:\n\n```java\nint number = 10; // Переменная типа int \ndouble pi = 3.14; // Переменная типа double \nboolean isJavaFun = true; // Переменная типа boolean\n```"
    },
    {
        block: "JAVA",
        question: "Принцип работы джава",
        answer: "•  Написание кода: Программист пишет код на языке программирования Java, используя текстовый редактор или интегрированную среду разработки (IDE).\n•  Компиляция: Написанный код сохраняется в файле с расширением .java. Затем этот код компилируется с помощью компилятора javac, который преобразует его в байт-код (специальный промежуточный код) и сохраняет его в файле с расширением .class.\n•  Запуск программы: Чтобы выполнить программу, байт-код загружается в Java Virtual Machine (JVM). JVM является виртуальной машиной, которая интерпретирует байт-код и выполняет его на конкретной платформе (например, Windows, macOS, Linux).\n•  Выполнение байт-кода: JVM выполняет байт-код, используя интерпретатор или Just-In-Time (JIT) компилятор, который динамически компилирует байт-код в машинный код для более быстрой работы. JVM управляет памятью и выполняет сборку мусора, освобождая память от ненужных объектов."
    },
    {
        block: "JAVA",
        question: "Условный оператор - if",
        answer: "Условный оператор if в Java используется для выполнения блока кода, если заданное условие истинно (true).\n\nСинтаксис:\n```java\nif (условие) {\n    // Блок кода, который выполняется, если условие истинно\n} else if (другое условие) {\n    // Блок кода, который выполняется, если другое условие истинно\n} else {\n    // Блок кода, который выполняется, если все условия ложны\n}\n```\n\nПример:\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int number = 3;\n\n        // Проверяем, является ли число больше 5\n        if (number > 5) {\n            System.out.println('Number is greater than 5');\n        } else {\n            System.out.println('Number is not greater than 5');\n        }\n    }\n}\n```"
    },
    {
        block: "JAVA",
        question: "Оператор - switch",
        answer: "Оператор switch в Java используется для выбора одного из нескольких блоков кода, которые будут выполнены на основе значения переменной. Он удобен для ситуаций, когда нужно сравнить одну переменную с несколькими значениями. Использование break в конце каждого case предотвращает выполнение следующих случаев. Если break не используется, выполнение будет продолжаться до первого найденного break или конца оператора switch. Блок default является необязательным, но его рекомендуется включать для обработки непредвиденных значений.\n\nПрименяется к:\n• Enum\n• String\n• Character, char\n• Byte, byte\n• Short, short\n• Integer, int\n\nНе применяется к:\n• Double\n• Float\n\nСинтаксис:\n```java\nswitch (выражение) {\n    case значение1:\n        // Блок кода для значение1\n        break;\n    case значение2:\n        // Блок кода для значение2\n        break;\n    // Вы можете добавить больше случаев\n    default:\n        // Блок кода по умолчанию\n        // Выполняется, если ни один из case не совпадает\n}\n```"
    },
    {
        block: "JAVA",
        question: "Тернарный/условный оператор",
        answer: "Тернарный оператор в Java, также известный как условный оператор, предоставляет короткую форму для записи простых условных выражений. Он позволяет написать условие, которое возвращает одно из двух значений в зависимости от истинности условия.\n\nпеременная = (условие) ? значение1 : значение2;\n\n• условие: Условие, которое проверяется.\n• значение1: Возвращается, если условие истинно (true).\n• значение2: Возвращается, если условие ложно (false).\n\nПример 1: Определение наибольшего числа\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int a = 10;\n        int b = 20;\n\n        // Использование тернарного оператора для нахождения наибольшего числа\n        int max = (a > b) ? a : b;\n\n        System.out.println('Наибольшее число: ' + max);\n    }\n}\n```"
    },
    {
        block: "JAVA",
        question: "Цикл while, do while и for",
        answer: "• Цикл while\nЦикл while проверяет условие перед каждой итерацией. Если условие истинно, выполняется тело цикла.\nСинтаксис:\nwhile (условие) { \n// код для выполнения\n }\nПример:\npublic class Main {\n    public static void main(String[] args) {\n        int i = 0;\n        while (i < 5) { // проверка условия перед каждой итерацией\n            System.out.println('i = ' + i);\n            i++; // увеличение значения переменной\n        }\n    }\n}\n• Цикл do-while\nЦикл do-while выполняет тело цикла хотя бы один раз, а затем проверяет условие. Если условие истинно, цикл продолжается.\nСинтаксис:\ndo {\n    // код для выполнения\n} while (условие);\nПример:\npublic class Main {\n    public static void main(String[] args) {\n        int i = 0;\n        do {\n            System.out.println('i = ' + i);\n            i++; // увеличение значения переменной\n        } while (i < 5); // проверка условия после каждой итерации\n    }\n}\n• Цикл for\nЦикл for используется, когда количество итераций известно заранее. Он включает инициализацию, условие и обновление в одном выражении.\nСинтаксис:\nfor (инициализация; условие; обновление) {\n    // код для выполнения\n}\nПример:\npublic class Main {\n    public static void main(String[] args) {\n        for (int i = 0; i < 5; i++) { // инициализация, условие и обновление в одном выражении\n            System.out.println('i = ' + i);\n        }\n    }\n}\nПрерывание итерирования в цикле\nДля For, While, do while:\n• Break - Позволяет прервать итерирование в цикле\n• Continue - Позволяет прервать текущую итерацию внутри цикле"
    },
    {
        block: "JAVA",
        question: "Массивы",
        answer: "Массивы в Java представляют собой структуры данных, которые позволяют хранить фиксированное количество элементов одного типа. Индексация массивов начинается с нуля.\nСинтаксис\nтип[] имя_массива = new тип[размер];\nПример:\npublic class Main {\n    public static void main(String[] args) {\n        // Объявление массива целых чисел размером 5\n        int[] numbers = new int[5];\n        // Инициализация массива значениями\n        numbers[0] = 1;\n        numbers[1] = 2;\n        numbers[2] = 3;\n        numbers[3] = 4;\n        numbers[4] = 5;\n        // Вывод значений массива\n        for (int i = 0; i < numbers.length; i++) {\n            System.out.println('Element at index ' + i + ': ' + numbers[i]);\n        }\n    }\n}\nСвойства массивов\n• Структурированность - Все элементы массива жестко привязаны к своим индексам\n• Статичность - Размер массива определяется в момент создания массива и не изменяется\n• Однородность - Массив хранит объекты только одного типа данных"
    },
    {
        block: "JAVA",
        question: "Работа с файлами. Чтение. Запись",
        answer: "Чтение из файла:\n• FileInputStream - Чтение байтов из файла.\n• FileReader - Чтение символов из файла.\n• BufferInputStream - Буферизированное чтение байтов из файла для повышения производительности.\nЗапись в файл:\n• FileOutputStream - Запись байтов в файл.\n• FileWriter - Запись символов в файл.\n• BufferOutputStream - Буферизированная запись байтов в файл для повышения производительности."
    },
    {
        block: "JAVA",
        question: "Класс в Java",
        answer: "Класс - шаблон, на основе которого создаются экземпляры (инстансы, объекты).\nСостав класса в Java\n1. Поля (Fields) - переменные, хранящие данные объекта.\nПорядок инициализации полей:\n• В объявлении класса и блоке инициализации в том порядке, в котором они идут в самом классе,\n• В конструкторе.\nИнициализация полей, если их значение не задано:\n• Числа – 0,\n• Логические переменные – false,\n• Ссылки на объект - null.\n2. Методы (Methods) - функции, которые описывают поведение объекта.\nПараметры методов передаются по:\n• Значению - не может модифицировать передаваемый объект, используется\n• Ссылке - может модифицировать, встречается в других ЯП.\n3. Конструкторы (Constructors) - специальные методы, вызываемые при создании объекта.\nКонструктор - метод для создания и инициализации экземпляра класса.\n• Может быть несколько.\n• Нельзя применить к существующему объекту.\n• Всегда вызывается с операцией new.\nЕсли в классе отсутствует определение конструктора, то при создании экземпляра вызывается конструктор по умолчанию.\n4. Инициализаторы (Initializers) - блоки кода для инициализации полей.\nВнутри блока инициализации можно не только задавать значения переменным, но и вызывать методы.\n5. Вложенные классы (Nested Classes) - классы, определенные внутри другого класса."
    },
    {
        block: "JAVA",
        question: "Примитивы vs Объекты",
        answer: "Примитивные типы представляют простые значения и не содержат методов. Они обладают фиксированным размером и используются для хранения базовых данных.\nПримеры примитивных типов:\n• byte: 8-битное целое число\n• short: 16-битное целое число\n• int: 32-битное целое число\n• long: 64-битное целое число\n• float: 32-битное число с плавающей точкой\n• double: 64-битное число с плавающей точкой\n• char: 16-битный символ Unicode\n• boolean: логическое значение (true или false)\nОбъекты представляют сложные данные и могут содержать поля и методы. Объекты являются экземплярами классов.\nПримеры объектов:\n• String: последовательность символов\n• Integer: обертка для типа int\n• Double: обертка для типа double\n• Пользовательские классы (например, Person)\nСравнение Примитивов и Объектов\n1. Память:\n• Примитивы хранятся в стеке и имеют фиксированный размер.\n• Объекты хранятся в куче и их размер зависит от содержимого.\n2. Производительность:\n• Примитивы работают быстрее и занимают меньше памяти.\n• Объекты медленнее и требуют больше памяти из-за накладных расходов на объекты.\n3. Использование:\n• Примитивы используются для простых операций.\n• Объекты используются для сложных структур данных и функциональности.\n4. Методы:\n• Примитивы не имеют методов.\n• Объекты имеют методы и могут использоваться с дополнительной функциональностью."
    },
    {
        block: "JAVA",
        question: "List, ArrayList, LinkedList",
        answer: "List — это интерфейс в Java, представляющий упорядоченный набор элементов. Элементы могут дублироваться, и каждый элемент имеет свой индекс.\nОсновные методы:\n• add(E e): добавляет элемент.\n• get(int index): возвращает элемент по индексу.\n• remove(int index): удаляет элемент по индексу.\n• size(): возвращает размер списка.\nArrayList — реализация интерфейса List, использующая динамический массив для хранения элементов.\nОсновные характеристики:\n• Быстрый доступ по индексу (O(1)).\n• Медленное добавление и удаление элементов в середине списка (O(n)).\n• Идеально подходит для чтения и редких изменений.\nLinkedList — реализация интерфейса List, использующая связный список для хранения элементов.\nОсновные характеристики:\n• Медленный доступ по индексу (O(n)).\n• Быстрое добавление и удаление элементов в начале или середине списка (O(1)).\n• Подходит для частых вставок и удалений.\nВыбор между ArrayList и LinkedList:\n• ArrayList: Используйте, когда важен быстрый доступ по индексу и операции вставки/удаления редки.\n• LinkedList: Используйте, когда важны частые вставки/удаления элементов в середине или начале списка."
    },
    {
        block: "JAVA",
        question: "Map",
        answer: "Map — это интерфейс в Java, представляющий коллекцию пар 'ключ-значение'. В Map каждый ключ связан с точно одним значением. Ключи должны быть уникальными.\nОсновные реализации Map:\n• HashMap: базовая реализация Map, не сохраняющая порядок элементов.\n• LinkedHashMap: сохраняет порядок вставки элементов.\n• TreeMap: хранит элементы в отсортированном порядке по ключам.\nОсновные методы Map:\n• put(K key, V value): добавляет пару 'ключ-значение'.\n• get(Object key): возвращает значение по ключу.\n• remove(Object key): удаляет элемент по ключу.\n• containsKey(Object key): проверяет наличие ключа.\n• containsValue(Object value): проверяет наличие значения.\n• size(): возвращает количество элементов.\n• clear(): очищает коллекцию.\n• isEmpty(): возвращает true, если коллекция пуста."
    },
    {
        block: "JAVA",
        question: "Set",
        answer: "Set — это интерфейс в Java, представляющий коллекцию уникальных элементов. В Set не допускаются дубликаты.\nОсновные реализации Set:\n• HashSet: базовая реализация Set, не сохраняющая порядок элементов.\n• LinkedHashSet: сохраняет порядок вставки элементов.\n• TreeSet: хранит элементы в отсортированном порядке.\nОсновные методы Set:\n• add(E e): добавляет элемент в Set.\n• remove(Object o): удаляет элемент из Set.\n• contains(Object o): проверяет наличие элемента.\n• size(): возвращает количество элементов.\n• clear(): удаляет все элементы."
    },
    {
        block: "SQL",
        question: "SQL",
        answer: "Структурированный, декларативный язык программирования (запросов), применяемый для создания, модификации и управления данными в реляционной базе данных, управляемой соответствующей системой управления базами данных."
    },
    {
        block: "SQL",
        question: "База данных",
        answer: "Это упорядоченный набор структурированной информации которые хранятся в электронном виде. База данных управляется системой управления базами данных (СУБД). Данные вместе с СУБД, а также приложения, которые с ними связаны, называются системой баз данных, или, для краткости, просто базой данных."
    },
    {
        block: "SQL",
        question: "Система управления базами данных",
        answer: "Комплекс программ, позволяющих создать базу данных (БД) и манипулировать данными (вставлять, обновлять, удалять и выбирать). Система обеспечивает безопасность, надёжность хранения и целостность данных, а также предоставляет средства для администрирования БД.\nПримеры СУБД:\n• Oracle Database,\n• Firebird, Interbase,\n• IBM DB2,\n• Informix,\n• MS SQL Server,\n• Sybase Adaptive Server Enterprise,\n• PostgreSQL,\n• MySQL,\n• Caché,\n• ЛИНТЕР"
    },
    {
        block: "SQL",
        question: "Реляционная модель",
        answer: "С интуитивно понятной таблице. Блоки в ней связаны и соотносятся между собой по заранее определенным правилам. В реляционных базах пользователь воспринимает данные в виде таблиц. В формальной теории реляционных баз данных эти таблицы называются отношениями (relations) – поэтому и базы данных называются реляционными."
    },
    {
        block: "SQL",
        question: "Декларативный и императивный подходы",
        answer: "• Декларативное программирование — парадигма программирования, в которой задается спецификация решения задачи, то есть описывается ожидаемый результат, а не способ его получения. Противоположностью декларативного является императивное программирование, при котором на том или ином уровне детализации требуется описание последовательности шагов для решения задачи.\n• Императивное программирование — императивная программа похожа на приказы (англ. imperative — приказ, повелительное наклонение), то есть представляют собой последовательность команд, которые должен выполнить процессор."
    },
    {
        block: "SQL",
        question: "Типы данных БД",
        answer: "• int8 - знаковое целое из 8 байт\n• char [ (n) ] - символьная строка фиксированной длины\n• varchar [ (n) ] - символьная строка переменной длины\n• float8 - число двойной точности с плавающей точкой (8 байт)\n• int, int4 - знаковое четырехбайтовое целое\n• timetz - время суток с учётом часового пояса\n• timestamptz - дата и время с учётом часового пояса"
    },
    {
        block: "SQL",
        question: "Операторы SQL",
        answer: "SQL содержит 4 группы операторов:\n• Операторы описания данных (DDL): CREATE, DROP, ALTER и др.\n• Операторы манипуляции данными (DML): INSERT, DELETE, SELECT, UPDATE и др.\n• Операторы задания прав доступа в базе данных (DCL): GRANT / REVOKE , LOCK / UNLOCK , SET LOCK MODE\n• Операторы защиты, восстановления данных и прочие операторы."
    },
    {
        block: "SQL",
        question: "DDL (Data Definition Language) операторы определения/описания данных",
        answer: "• CREATE DATABASE example; - В любой момент времени вы можете иметь доступ к объектами только одной - ТЕКУЩЕЙ (CURRENT) - базы данных.\n• CREATE TABLE example (number int, name char(20));\n• ALTER TABLE table_name\n• ALTER COLUMN column_name [SET DATA] TYPE new_data_type - Изменение структуры таблицы приводит к физическому преобразованию данных в ней. Если изменен тип столбца, то данные в нем преобразуются к новому типу, и если это невозможно осуществить, то оператор ALTER 'валится' с кодом ошибки, а таблица остается в неизмененном состоянии.\n• CREATE INDEX indkdtb ON example (name) - создан индекс для столбца name из таблицы example. Индекс - дополнительная структура к столбцам таблицы, нужен для ускорения поиска значений в столбце."
    },
    {
        block: "SQL",
        question: "DML (Data Manipulation Language) операторы манипуляции данными",
        answer: "• DELETE FROM kadry WHERE ceh=4 AND fio MATCHES '*ов' - этот оператор уничтожит ВСЕ строки в таблице kadry\n• SELECT DISTINCT zarplata FROM kadry WHERE tabnom=345 - Пример находит в таблице kadry строку, в которой столбец tabnum=345. Из этой строки берутся только три указанных столбца.\n• INSERT INTO kadry VALUES (4,0,'Грицько',num,'10/25/1939',NULL) - Может вставить в таблицу одну строку, если используется в форме INSERT INTO ... VALUES, а может вставить в таблицу целый набор строк, выбранных подзапросом SELECT из другой таблицы.\n• UPDATE kadry SET fio='Зыкова' WHERE fio='Гирусова' - Меняет значения столбцов, в строках, удовлетворяющим WHERE условию\n• Оператор DISTINCT используется для указания на то, что следует работать только с уникальными значениями столбца."
    },
    {
        block: "SQL",
        question: "DCL (Data Control Language) операторы управления доступом",
        answer: "• GRANT: Этот оператор предоставляет привилегии пользователям или ролям. Привилегии могут быть предоставлены на таблицы, представления, функции и другие объекты базы данных.\n• GRANT SELECT, INSERT ON table_name TO user_name;\n• REVOKE: Этот оператор отменяет предоставленные ранее привилегии. Он может быть использован для отзыва привилегий с таблиц, представлений и других объектов базы данных.\n• REVOKE SELECT, INSERT ON table_name FROM user_name;\n• ALTER DEFAULT PRIVILEGES: Этот оператор позволяет изменять привилегии по умолчанию для новых объектов базы данных, созданных пользователем или ролью.\n• ALTER DEFAULT PRIVILEGES FOR ROLE role_name IN SCHEMA schema_name GRANT SELECT ON TABLES TO PUBLIC;\n• SET ROLE: Этот оператор используется для изменения текущей роли сессии на указанную роль.\n• SET ROLE role_name / RESET ROLE;"
    },
    {
        block: "SQL",
        question: "Агрегирование",
        answer: "• Агрегирующие функций - функций вычисляющих результат по набору значений группы.\n• SUM(<выражение>) Выводит в итоговой таблице сумму значений для выражения по полям выборки.\n• AVG(<выражение>) Среднее значение для выражения. Выражение должно возвращать числовое значение.\n• COUNT(<выражение>) Подсчитывает число записей, в которые выражение не имеет значения (поля имеют значение Null, когда никакое значение для них не задано). Выражение может возвращать произвольное значение.\n• MAX(<выражение>) Возвращает максимальное значение выражения для выборки.\n• MIN(<выражение>) Возвращает минимальное значение выражения из выборки."
    },
    {
        block: "SQL",
        question: "Оператор WHERE",
        answer: "Оператор WHERE может присутствовать в любом из операторов DELETE, UPDATE, SELECT, когда нужно задать условия на строки, которые требуется обработать (соответственно, уничтожить, изменить или выбрать). В операторе WHERE пишется логическое условие, которое получается соединением с помощью логических операторов AND, OR и NOT элементарных сравнений типа:\n• выражение 1 (<,>,>=,<= и т.п.) выражение 2,\n• column-name IS [NOT] ...\nТакже элементарных сравнений специального вида:\n• выражение [NOT] BETWEEN выражение 1 AND выражение 2\nМожно выяснить, подходит ли символьная строка под определенный шаблон, или нет. Для этого используются две операции сравнения по шаблону - LIKE и MATCHES.\n• символ - выражение LIKE 'шаблон'\n• символ - выражение MATCHES 'шаблон'"
    },
    {
        block: "SQL",
        question: "LIKE и MATCHES",
        answer: "• LIKE имеет более простой шаблон. В нем используются только два спецсимвола: (%) замещает произвольное количество символов, (_) замещает ровно один символ. Все остальные символы в шаблоне обозначают сами себя. Если мы хотим включить в шаблон % или _ отменив их специальный смысл, то перед ними надо поставить ESC символ (по умолчанию это (\)).\n• MATCHES использует такие спецсимволы шаблона: *, ?, [, ], ^, -.\n* - заменяет любое количество символов\n? - заменяет один любой символ\n[...] - заменяет один символ из перечисленных в скобках возможно указание от и до (-), и не (^):\n[abH] - любой из символов a, b, H\n[^d-z] - любой символ, исключая d,e,f,g, ...,y,z\n\ - отменяет спецсмысл спецсимволов *,?,[,]"
    },
    {
        block: "SQL",
        question: "Условия с Подзапросом",
        answer: "• SELECT fio FROM kadry WHERE zarplata = (SELECT MAX(zarplata) FROM kadry) - Здесь подзапрос возвращает единственное значение - максимальное значение зарплаты. А внешний SELECT оператор находит фамилии обладателей оной.\n• SELECT fio, shifr, organizaciq FROM zaqwki WHERE denxgi_rek is not and gorod in (SELECT gorod FROM regiony WHERE region='Урал') - Здесь запрос выводит данные о руководителях, получивших финансирование и работающих на Урале.\n• SELECT order_num,stock_num,manu_code, total_price FROM items x WHERE total_price > (SELECT 2*MIN(total_price) FROM items WHERE order_num=x.order_num) - Этот запрос (используя связанный подзапрос) выводит список всех изделий, чья общая цена не менее чем в два раза превосходит минимальную цену изделий перечисленных в этом же ордере. Вы можете соединять любое количество вышеперечисленных условий вместе, используя логические операторы NOT, AND, OR."
    },
    {
        block: "SQL",
        question: "Group by",
        answer: "Команда GROUP BY в SQL используется для группировки строк в таблице по одному или нескольким столбцам. Это позволяет выполнять агрегатные функции (например, SUM, COUNT, AVG) на каждой группе.\n• SELECT age, SUM(salary) as sum FROM employees GROUP BY age\n• SELECT age, SUM(salary) as sum FROM employees WHERE id>=2 GROUP BY age\n• SELECT age, MAX(salary) as max FROM employees GROUP BY age\n• SELECT age, COUNT(*) as count FROM employees GROUP BY age\nКоманда HAVING позволяет фильтровать результат группировки, сделанной с помощью команды GROUP BY."
    },
    {
        block: "SQL",
        question: "ORDER BY",
        answer: "Команда ORDER BY позволяет сортировать записи по определенному полю при выборе из базы данных.\nSELECT * FROM имя_таблицы WHERE условие ORDER BY поле_для_сортировки\nПо умолчанию записи сортируются по возрастанию, чтобы отсортировать по убыванию – поставьте DESC:\nSELECT * FROM имя_таблицы WHERE условие ORDER BY поле DESC\nПо умолчанию будет сортировка, будто поставлено ASC:\nSELECT * FROM имя_таблицы WHERE условие ORDER BY поле ASC"
    },
    {
        block: "SQL",
        question: "JOIN",
        answer: "Команды JOIN, INNER JOIN, LEFT JOIN, RIGHT JOIN используются для связывания таблиц по определенным полям связи.\nSELECT поля FROM имя_таблицы\nLEFT JOIN имя_связанной_таблицы ON условие_связи\nWHERE условие_выборки\n• В SQL используют операторы соединения join, чтобы объединять данные из нескольких таблиц. Когда результат должен содержать только данные двух таблиц с общим ключом, применяют INNER JOIN или просто JOIN.\n• Если нужен полный список записей одной из таблиц, объединенных с данными из другой, используют операторы LEFT и RIGHT JOIN.\n• Если результат должен содержать полный список записей обеих таблиц, где некоторые записи объединены, применяют оператор FULL JOIN."
    },
    {
        block: "SQL",
        question: "UNION",
        answer: "Команда UNION объединяет данные из нескольких таблиц в одну при выборке. При объединении количество столбцов во всех таблицах должно совпадать, иначе будет ошибка Имена столбцов будут такие же, как в основной таблице, в которую добавляются данные из других таблиц.\nSELECT * FROM имя_таблицы1 WHERE условие\nUNION SELECT * FROM имя_таблицы2 WHERE условие\nUNION SELECT * FROM имя_таблицы3 WHERE условие\nUNION SELECT * FROM имя_таблицы4 WHERE условие"
    },
    {
        block: "SQL",
        question: "Транзакции, key-value БД",
        answer: "• Структура: Базы данных «ключ-значение» — это тип базы данных NoSQL, в которой данные хранятся в виде набора пар «ключ-значение». Каждый ключ уникален и используется для получения соответствующего значения.\n• Хранение данных: Базы данных «ключ-значение» хранят данные распределенным образом, каждая пара ключ-значение обычно хранится в виде сериализованного объекта или двоичного объекта, что обеспечивает эффективное хранение и извлечение данных.\nПреимущества key-value БД:\n1. Простота модели данных: имеют простую структуру данных, представляющую собой набор пар ключ-значение. Это делает их легкими для понимания и использования, особенно для приложений с простыми структурами данных или для быстрого прототипирования.\n2. Высокая производительность: базы данных ключ-значение обычно обеспечивают высокую производительность при операциях записи и чтения, так как доступ к данным осуществляется по ключу, что позволяет быстро находить нужное значение без необходимости выполнения сложных запросов.\n3. Гибкость: такие базы данных обычно предоставляют гибкие возможности конфигурации и масштабирования. Они могут быть легко масштабируемы горизонтально, добавляя новые узлы кластера для увеличения производительности и емкости хранения.\n*Базы данных ключ-значение обычно предназначены для простых операций чтения и записи, и не поддерживают сложные операции запросов, типичные для реляционных баз данных.\nВарианты использования key-value БД:\n• Кэширование: Базы данных «ключ-значение» обычно используются для кэширования часто используемых данных. Сохраняя данные в памяти, они могут значительно повысить производительность приложений.\n• Управление сеансами: Базы данных «ключ-значение» можно использовать для управления сеансами пользователей. Они обеспечивают быстрое и эффективное хранение и извлечение сеансов.\n• Аналитика в реальном времени: Базы данных «ключ-значение» хорошо подходят для приложений аналитики в реальном времени. Они обеспечивают быстрый доступ к данным и могут обрабатывать большие объемы данных."
    },
    {
        block: "SQL",
        question: "Транзакции БД",
        answer: "• Транзакции это архив для запросов к базе. Он защищает ваши данные благодаря принципу «всё, или ничего». Упорядоченное множество операций, переводящих базу данных из одного согласованного состояния в другое.\n• Согласованное состояние — это состояние, которое подходит под бизнес-логику системы. То есть у нас не остается отрицательный баланс после перевода денег, номер счета не «зависает в воздухе», не привязанный к человеку, и тому подобное.\n*Одной операции всегда соответствует одна транзакция, но в рамках одной транзакции можно совершить несколько операций (например, несколько разных insert можно сделать, или изменить и удалить данные...)."
    },
    {
        block: "SQL",
        question: "Как открыть транзакцию",
        answer: "В PostgreSQL автооткрытия транзакции, как такового, нет. Транзакция начинается явно с помощью команды BEGIN или при выполнении первой изменяющей данные операции (INSERT, UPDATE, DELETE):"
    },
    {
        block: "SQL",
        question: "Как закрыть транзакцию",
        answer: "Если вы не начинаете транзакцию явно с помощью команды BEGIN, PostgreSQL автоматически начнет транзакцию при выполнении первой изменяющей данные операции. Это связано с тем, что PostgreSQL использует режим автокоммита по умолчанию. Таким образом, каждая операция будет автоматически закрыта коммитом после выполнения, если она не является частью явно начатой транзакции."
    },
    {
        block: "SQL",
        question: "Ключи в PostgreSQL",
        answer: "Первичный ключ: Отдельное поле, которое однозначно определяют запись. Ни одно из полей, являющихся частью первичного ключа не может содержать значение NULL. Таблица может иметь только один первичный ключ.\nВнешний ключ или foreign key: Внешний ключ нужен для того, чтобы связать две разные SQL-таблицы между собой. Внешний ключ таблицы должен соответствовать значению первичного ключа таблицы, с которой он связан. Это помогает сохранять согласованность базы данных путем обеспечения так называемой «ссылочной целостности» (referential integrity)."
    },
    {
        block: "SQL",
        question: "Индексы в PostgreSQL",
        answer: "Индексы - структура данных, особые таблицы, используемые поисковыми системами для поиска данных. Индекс ускоряет процесс запроса, предоставляя быстрый доступ к строкам данных в таблице, аналогично тому, как указатель в книге помогает вам быстро найти необходимую информацию.\nОсобенность индексов:\n• Индекс ускоряет поиск данных: При SELECT особенно если используется WHERE с условием равенства - WHERE 'my_column' = 12 (но не при использовании HAVING*)\n• В некоторых случаях индекс замедляет работу БД: Каждый раз при UPDATE и INSERT таблиц, данные в которых проиндексированы, системе так же необходимо обновить и все индексы."
    }
];
